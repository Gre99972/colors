<!DOCTYPE html>
<html>
<body>
<div id="mainBlock">

    <h1>Sorting algorithms swap comparisons</h1>
    <input id="statusTextCheckbox" type="checkbox" checked/><label>Status text</label>
    <input id="debugInfoCheckbox" type="checkbox" checked/><label>Debug info</label>

</div>
<script>

    const GLOBAL_COLOUR_MAP = [];
    let globalMapBuilt = false;

    class AsIsArrayWrapper {
        constructor(arrayToWrap) {
            this.wrappedArray = arrayToWrap;
            this.length = this.wrappedArray.length;
        }

        size() {
            return this.length;
        }

        get(index) {
            return this.wrappedArray[index];
        }

        set(value, index) {
            this.wrappedArray[index] = value;
        }
    }

    class CanvasArrayWrapper {
        constructor(canvasDataArray, from, to, i) {
            if (from < 0) {
                console.error("fuck you 1");
            }
            if (to > canvasDataArray.length - 4) {
                console.error("fuck you 2");
            }
            if (from > to) {
                console.error("fuck you 3");
            }
            this.length = to - from;
            if ((this.length % 4) !== 0) {
                console.error("fuck you 4");
            }
            this.canvasDataArray = canvasDataArray;
            this.from = from;
            this.to = to;
            this.length = this.length / 4 + 1;
        }

        size() {
            return this.length;
        }

        set(colourValue, index) {
            const offset = this.from + index * 4;
            this.canvasDataArray[offset] = colourValue.red;
            this.canvasDataArray[offset + 1] = colourValue.green;
            this.canvasDataArray[offset + 2] = colourValue.blue;
            //this.canvasDataArray[offset + 3] = 255;
        }

        get(index) {
            const offset = this.from + index * 4;
            const red = this.canvasDataArray[offset];
            const green = this.canvasDataArray[offset + 1];
            const blue = this.canvasDataArray[offset + 2];
            return GLOBAL_COLOUR_MAP[red][green][blue];
        }
    }

    class SorterSummary {

        constructor(name, constructorMethod, description) {
            this.name = name;
            this.constructorMethod = constructorMethod;
            this.description = description;
        }
    }


    class BubbleSorter {
        constructor(wrappedArrayToSort, comparator) {
            this.arr = wrappedArrayToSort;
            this.comparator = comparator;
            this.reset();
        }

        reset() {
            this.patientInd = 0;
        }

        oneTick() {
            for (let i = this.patientInd + 1; i < this.arr.size() - 1; i++) {
                let patient = this.arr.get(this.patientInd);
                let toComp = this.arr.get(i + 1);
                if (this.comparator(patient, toComp) > 0) {
                    this.arr.set(toComp, this.patientInd);
                    this.arr.set(patient, i + 1);
                    return true;
                }
            }
            this.patientInd += 1;
            return this.patientInd === this.arr.size() - 1;
        }
    }

    class InsertionSorter {
        constructor(wrappedArrayToSort, comparator) {
            this.arr = wrappedArrayToSort;
            this.comparator = comparator;
        }

        reset() {
            this.patientInd = -1;
        }

        oneTick() {
            for (let i = this.patientInd + 1; i < this.arr.size() - 1; i++) {
                let patient = this.arr.get(i);
                let toComp = this.arr.get(i + 1);
                if (this.comparator(patient, toComp) > 0) {
                    this.arr.set(toComp, i);
                    this.arr.set(patient, i + 1);
                    return true;
                }
            }
            this.patientInd += 1;
            return this.patientInd === this.arr.size() - 1;
        }
    }


    class Slice {
        constructor(low, high) {
            this.low = low;
            this.high = high;
            this.i = null;
            this.j = null;
            this.midElem = null;
        }
    }

    class QuickSorter {

        constructor(wrappedArrayToSort, comparator) {
            this.arr = wrappedArrayToSort;
            this.comparator = comparator;
            this.reset();
        }

        reset() {
            this.slicesToSort = [new Slice(0, this.arr.size() - 1)];
        }

        oneTick() {
            while (this.slicesToSort.length > 0) {
                let slice = this.slicesToSort.pop();
                if (slice.low < slice.high) {
                    let midElem = slice.midElem || this.arr.get(Math.floor(slice.low + (slice.high - slice.low) / 2));
                    slice.midElem = midElem;
                    let i = slice.i || slice.low;
                    let j = slice.j || slice.high;
                    while (i <= j) {
                        while (this.comparator(this.arr.get(i), midElem) < 0) {
                            i++;
                        }
                        while (this.comparator(this.arr.get(j), midElem) > 0) {
                            j--;
                        }
                        if (i <= j) {
                            let tmp = this.arr.get(i);
                            this.arr.set(this.arr.get(j), i);
                            this.arr.set(tmp, j);
                            slice.i = i + 1;
                            slice.j = j - 1;
                            this.slicesToSort.push(slice);
                            return true;
                        }
                    }
                    if (slice.low < j) {
                        this.slicesToSort.push(new Slice(slice.low, j));
                    }
                    if (slice.high > i) {
                        this.slicesToSort.push(new Slice(i, slice.high));
                    }
                    //shuffle(this.slicesToSort)
                }
            }
            return false;
        }
    }


    class PartToMerge {
        constructor(low, high) {
            this.low = low;
            this.high = high;
            this.len = high - low;
        }

        hasSomething() {
            return this.low < this.high;
        }
    }

    class MergeSorter {
        constructor(wrappedArrayToSort, comparator) {
            this.arr = wrappedArrayToSort;
            this.comparator = comparator;
            this.reset();
        }

        reset() {
            this.partsToMerge = [];
            this.persistingInProgress = false;
            this.sortedPartReadyToBePersisted = [];
            this.mainArrayPointer = null;
            for (let i = 0; i < this.arr.size(); i++) {
                this.partsToMerge.push(new PartToMerge(i, i + 1));
            }
        }

        oneTick() {
            if (this.sortedPartReadyToBePersisted.length > 0) {
                const elem = this.sortedPartReadyToBePersisted.shift();
                this.arr.set(elem, this.mainArrayPointer++);
                return true;
            } else {
                while (this.partsToMerge.length > 1) {
                    let right = this.partsToMerge.pop();
                    let left = this.partsToMerge.pop();
                    if (right.len < left.len) {
                        if (this.partsToMerge.length > 0) {
                            this.partsToMerge.unshift(right);
                            right = left;
                            left = this.partsToMerge.pop();
                        }
                    }
                    const newLow = Math.min(left.low, right.low);
                    const newHigh = newLow + left.len + right.len;
                    while (left.hasSomething() && right.hasSomething()) {
                        let fromTheLeft = this.arr.get(left.low);
                        let fromTheRight = this.arr.get(right.low);
                        if (this.comparator(fromTheLeft, fromTheRight) < 0) {
                            this.sortedPartReadyToBePersisted.push(fromTheLeft);
                            left.low++;
                        } else {
                            this.sortedPartReadyToBePersisted.push(fromTheRight);
                            right.low++;
                        }
                    }
                    while (left.hasSomething()) {
                        this.sortedPartReadyToBePersisted.push(this.arr.get(left.low++));
                    }
                    while (right.hasSomething()) {
                        this.sortedPartReadyToBePersisted.push(this.arr.get(right.low++));
                    }
                    this.mainArrayPointer = newLow;
                    this.partsToMerge.unshift(new PartToMerge(newLow, newHigh));
                    return true;
                }
            }
            return false;
        }
    }


    class HeapSorter {

        constructor(wrappedArrayToSort, comparator) {
            this.arr = wrappedArrayToSort;
            this.comparator = comparator;
            this.reset();
        }

        reset() {
            this.heapPreparationDone = false;
            this.heapSortingSwapJustDone = false;
            this.heapSize = this.arr.size();
            this.heapSortingI = this.arr.size() - 1;
            this.heapPreparationI = Math.floor(this.arr.size() / 2);
            this.heapNextMax = this.heapPreparationI;
        }

        oneTick() {
            if (!this.heapPreparationDone) {
                if (this.heapPreparationI <= 0 && this.heapNextMax === null) {
                    this.heapPreparationDone = true;
                } else {
                    if (this.heapNextMax === null) {
                        this.heapNextMax = --this.heapPreparationI
                    }
                    this.heapNextMax = this.sortHeapFrom(this.arr, this.heapNextMax, this.heapSize);
                    return true;
                }
            }
            if (this.heapSortingI > 0) {
                if (this.heapSortingSwapJustDone) {
                    if (this.heapNextMax === null) {
                        this.heapNextMax = 0;
                        --this.heapSize;
                    }
                    this.heapNextMax = this.sortHeapFrom(this.arr, this.heapNextMax, this.heapSize);
                    if (this.heapNextMax !== null) {
                        return true;
                    }
                    this.heapSortingI--;
                    this.heapSortingSwapJustDone = false;
                    return true;
                } else {
                    HeapSorter.swap(this.arr, 0, this.heapSortingI);
                    this.heapSortingSwapJustDone = true;
                    return true;
                }
            }
            return false;
        }

        sortHeapFrom(arr, nextMax, heapLength) {
            let left = 2 * nextMax + 1;
            let right = 2 * nextMax + 2;
            let max = nextMax;
            if (left < heapLength && this.comparator(arr.get(left), arr.get(max)) > 0) {
                max = left;
            }
            if (right < heapLength && this.comparator(arr.get(right), arr.get(max)) > 0) {
                max = right;
            }
            if (max !== nextMax) {
                HeapSorter.swap(arr, nextMax, max);
                return max;
            }
            return null;
        }

        static swap(arr, i, j) {
            let tmp = arr.get(i);
            arr.set(arr.get(j), i);
            arr.set(tmp, j);
        }
    }

    function shuffle(a) {
        for (let i = a.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [a[i], a[j]] = [a[j], a[i]];
        }
    }


    const allSorters = [
        new SorterSummary(
            "Bubble Sort",
            function (array, comparator) {
                return new BubbleSorter(array, comparator);
            },
            "This is a basic bubble sort impl."),
        new SorterSummary(
            "Insertion Sort",
            function (array, comparator) {
                return new InsertionSorter(array, comparator);
            },
            "This is a basic insertion sort impl."),

        new SorterSummary(
            "Merge Sort",
            function (array, comparator) {
                return new MergeSorter(array, comparator);
            },
            "This is a strange version of a merge sort which commits every merge result back to the source array."),
        new SorterSummary(
            "Quick Sort",
            function (array, comparator) {
                return new QuickSorter(array, comparator);
            },
            "This is a basic implementation of the quick sort"),
        new SorterSummary(
            "Heap Sort",
            function (array, comparator) {
                return new HeapSorter(array, comparator);
            },
            "This is a heap sort implementation.")
    ];


    const mainBlock = document.getElementById("mainBlock");
    const statusTextCheckbox = document.getElementById("statusTextCheckbox");
    const debugInfoCheckbox = document.getElementById("debugInfoCheckbox");

    const maxColourValue = 255;
    const canvasWidth = mainBlock.offsetWidth;
    const step = maxColourValue * 5 / canvasWidth;

    const DEFAULT_COLOUR_COMP = function (c1, c2) {
        return c1.compare(c2);
    };

    class Colour {

        constructor(red, green, blue) {
            this.red = Colour.to255Range(red);
            this.green = Colour.to255Range(green);
            this.blue = Colour.to255Range(blue);
            this.hue = Colour.getWikiHue(this);
        }

        static to255Range(n) {
            return Math.ceil(Math.max(Math.min(n, 255), 0));
        }

        static getWikiHue(colour) {
            const R = colour.red;
            const G = colour.green;
            const B = colour.blue;

            if (R >= G && G >= B) {
                //return 60 * (G - B) / (R - B);
                return 60 * G / R;
            }
            if (G > R && R >= B) {
                return 60 * (2 - (R - B) / (G - B));
            }
            if (G >= B && B > R) {
                return 60 * (2 + (B - R) / (G - R));
            }
            if (B > G && G > R) {
                return 60 * (4 - (G - R) / (B - R));
            }
            if (B > R && R >= G) {
                return 60 * (4 + (R - G) / (B - G));
            }
            if (R >= B && B > G) {
                return 60 * (6 - (B - G) / (R - G));
            }
        }

        equals(other) {
            return this.red === other.red && this.green === other.green && this.blue === other.blue;

        }

        compare(other) {
            return this.hue - other.hue;
        }
    }

    class DebugInfo {
        constructor(mergerName) {
            this.mergerName = mergerName;
            this.reset();
        }

        reset() {
            this.startTime = new Date();
            this.numberOfDrawCalls = 0;
            this.numberOfTicks = 0;
            this.lastDrawCallStart = null;
            this.lastTickStart = null;
            this.avgDrawCallDuration = 0;
            this.avgTickDuration = 0;
        }

        timeSpent() {
            return "dahuia";
        }

        startDraw() {
            this.lastDrawCallStart = new Date();
        }

        endDraw() {
            if (!this.lastDrawCallStart) {
                throw "pashol nahui suka";
            }
            let now = new Date();
            let callDuration = now - this.lastDrawCallStart;
            this.avgDrawCallDuration = (this.avgDrawCallDuration * this.numberOfDrawCalls + callDuration) / ++this.numberOfDrawCalls;
        }

        startTick() {
            this.lastTickStart = new Date();
        }

        endTick() {
            if (!this.lastTickStart) {
                throw "vasche ahuel??";
            }
            let now = new Date();
            let tickDuration = now - this.lastTickStart;
            this.avgTickDuration = (this.avgTickDuration * this.numberOfTicks + tickDuration) / ++this.numberOfTicks;

        }
    }


    function REGISTER_ALL_THE_SHIT(sorterCanvas, constructorMethod, canvasWidth, canvasHeight, step) {
        let matrix = generateColourMatrix(canvasWidth, canvasHeight, step);
        cacheColourObjects(matrix[0]);
        matrix.id = sorterCanvas.id + " matrix";
        let sorted = true;
        let statusText;
        const ctx = sorterCanvas.getContext("2d");
        const imageData = ctx.getImageData(0, 0, sorterCanvas.width, canvasHeight);
        const actualData = imageData.data;
        const debugInfoObject = new DebugInfo("pahui zeleni");

        function DRAW() {
            debugInfoObject.startDraw();
            drawColourMatrix(matrix, ctx, imageData, actualData, canvasWidth);
            debugInfoObject.endDraw();
            if (statusText && statusTextCheckbox.checked) drawStatusText(ctx, statusText, canvasWidth);
            if (debugInfoCheckbox.checked) drawDebugStats(ctx, debugInfoObject, canvasWidth, canvasHeight);
        }

        function drawStatusText(ctx, textToDraw, canvasWidth) {
            ctx.fillStyle = "white";
            ctx.font = "bold 50px serif ";
            let textMeasurements = ctx.measureText(textToDraw);
            ctx.fillText(statusText, canvasWidth - textMeasurements.width - 15, 50);
        }

        function drawDebugStats(ctx, debugInfo, canvasWidth, canvasHeight) {
            let debugRectangleWidth = 200;
            let debugRectangleHeight = 100;
            let x = canvasWidth - debugRectangleWidth;
            let y = canvasHeight - debugRectangleHeight;
            ctx.fillStyle = 'rgba(5, 5, 5, 0.5)';
            ctx.fillRect(x, y, debugRectangleWidth, debugRectangleHeight);

            ctx.fillStyle = "white";
            ctx.font = "bold 15px serif ";

            let totalDrawCalls = "Total draw calls: " + debugInfo.numberOfDrawCalls;
            ctx.fillText(totalDrawCalls, x + 10, y + 20, debugRectangleWidth);

            let avgDrawCallDuration = "Avg Draw: "  + Number(debugInfo.avgDrawCallDuration).toFixed(2) + "ms";
            ctx.fillText(avgDrawCallDuration, x + 10, y + 35, debugRectangleWidth);

            let avgTickDuration = "Avg Tick: " + Number(debugInfo.avgTickDuration).toFixed(2) + "ms";
            ctx.fillText(avgTickDuration, x + 10, y + 50, debugRectangleWidth);


        }

        let sorters = [];
        for (let i = 0; i < matrix.length; i++) {
            sorters.push(constructorMethod(new CanvasArrayWrapper(actualData, 4 * i * canvasWidth, 4 * i * canvasWidth + canvasWidth * 4 - 4), DEFAULT_COLOUR_COMP));
        }

        let sortStarted = false;
        let chainedTick = function () {
            if (!sortStarted) {
                DRAW();
                return;
            }
            let somethingChanged = false;
            debugInfoObject.startTick();
            for (let i = 0; i < sorters.length; i++) {
                somethingChanged = sorters[i].oneTick() || somethingChanged;
            }
            debugInfoObject.endTick();
            if (!somethingChanged) {
                statusText = "All Sorted";
                sorted = true;
                sortStarted = false;
                debugInfoObject.reset();
                DRAW();
            } else {
                DRAW();
                window.requestAnimationFrame(chainedTick);
            }
        };

        function shuffleTheStuff() {
            for (let i = 0; i < matrix.length; i++) {
                shuffle(matrix[i]);
                sorters[i].reset();
            }
            sorted = false;
            statusText = "Shuffled"
        }

        shuffleTheStuff();
        statusText = "Click me";
        putMatrixToCanvasData(matrix, actualData, canvasWidth);
        DRAW();
        let regularClick = function () {
            if (sorted) {
                shuffleTheStuff();
                putMatrixToCanvasData(matrix, actualData, canvasWidth);
                DRAW();
            } else if (sortStarted) {
                statusText = "Paused";
                sortStarted = false;
            } else {
                statusText = "Sorting";
                sortStarted = true;
                chainedTick();
            }
        };
        sorterCanvas.onclick = regularClick;
    }

    allSorters.forEach(function (ss) {

        let sorterDiv = document.createElement('div');

        sorterDiv.id = ss.name + "-" + ss.name;
        let sorterName = document.createElement('h3');
        sorterName.innerHTML = ss.name;
        let sorterDescription = document.createElement('label');
        sorterDescription.innerHTML = ss.description;
        let br = document.createElement('br');

        const canvasHeight = Math.ceil(canvasWidth / 2.5);
        let sorterCanvas = document.createElement('canvas');
        sorterCanvas.id = ss.name + "CanvasId";
        sorterCanvas.width = canvasWidth;
        sorterCanvas.height = canvasHeight;
        sorterCanvas.innerHTML = "There should be HTML canvas with a pretty animation, but fuck you.";

        sorterDiv.appendChild(sorterName);
        sorterDiv.appendChild(sorterDescription);
        sorterDiv.appendChild(br);
        sorterDiv.appendChild(sorterCanvas);
        mainBlock.appendChild(sorterDiv);

        REGISTER_ALL_THE_SHIT(sorterCanvas, ss.constructorMethod, canvasWidth, canvasHeight, step);
    });


    function generateColourMatrix(width, height, step) {

        const rows = height;
        const columns = width;
        let colourMatrix = [];

        const D_UP = 0;
        const D_DOWN = 1;
        const D_TOP = 2;
        const D_BOTTOM = 3;
        const D_THE_MOST_BOTTOM = 4;
        const MAX_STEPS = maxColourValue / step;

        class ColorState {
            constructor(colorVal, direction, stepsDone) {
                this.colorVal = colorVal;
                this.direction = direction;
                this.stepsDone = stepsDone;
            }
        }

        let referenceRow = [];

        let red = new ColorState(maxColourValue, D_TOP, 0);
        let green = new ColorState(0, D_UP, 0);
        let blue = new ColorState(0, D_THE_MOST_BOTTOM, 0);
        let allTogether = [red, green, blue];
        for (let j = 0; j < columns; j++) {
            referenceRow.push(new Colour(red.colorVal, green.colorVal, blue.colorVal));
            allTogether.forEach(function (c) {
                if (c.stepsDone >= MAX_STEPS) {
                    switch (c.direction) {
                        case D_BOTTOM:
                            c.direction = D_UP;
                            break;
                        case D_TOP:
                            c.direction = D_DOWN;
                            break;
                        case D_UP:
                            c.direction = D_TOP;
                            break;
                        case D_DOWN:
                            c.direction = D_BOTTOM;
                            break;
                        case D_THE_MOST_BOTTOM:
                            c.direction = D_BOTTOM;
                            break;
                    }
                    c.stepsDone = 0;
                }
                switch (c.direction) {
                    case D_BOTTOM:
                        break;
                    case D_TOP:
                        break;
                    case D_UP:
                        c.colorVal += step;
                        break;
                    case D_DOWN:
                        c.colorVal -= step;
                        break;
                    case D_THE_MOST_BOTTOM:
                        break;
                }
                c.stepsDone++;
            });
        }
        for (let i = 0; i < rows; i++) {
            let newRow = [];
            for (let k = 0; k < referenceRow.length; k++) {
                let c = referenceRow[k];
                newRow.push(new Colour(c.red, c.green, c.blue));
            }
            colourMatrix.push(newRow);
        }
        return colourMatrix;
    }

    function cacheColourObjects(colours) {
        if (!globalMapBuilt) {
            for (let i = 0; i < colours.length; i++) {
                ADD_TO_GLOBAL_MAP(colours[i]);
            }
            globalMapBuilt = true;
        }
    }

    function ADD_TO_GLOBAL_MAP(colour) {
        if (!GLOBAL_COLOUR_MAP[colour.red]) {
            GLOBAL_COLOUR_MAP[colour.red] = [];
        }
        if (!GLOBAL_COLOUR_MAP[colour.red][colour.green]) {
            GLOBAL_COLOUR_MAP[colour.red][colour.green] = [];
        }
        GLOBAL_COLOUR_MAP[colour.red][colour.green][colour.blue] = colour;
    }

    function drawColourMatrix(matrix, canvasCtx, imageData, actualData, canvasWidth) {
        canvasCtx.putImageData(imageData, 0, 0);
    }

    function putMatrixToCanvasData(matrix, actualData, canvasWidth) {
        for (let i = 0; i < matrix.length; i++) {
            let row = matrix[i];
            for (let j = 0; j < row.length; j++) {
                let col = row[j];
                let offset = (i * canvasWidth) * 4 + j * 4;
                actualData[offset] = col.red;
                actualData[offset + 1] = col.green;
                actualData[offset + 2] = col.blue;
                actualData[offset + 3] = 255;
            }
        }
    }


</script>

</body>
</html>
