<!DOCTYPE html>
<html>
<body>
<div id="mainBlock">

    <h1>Sorting algorithms swap comparisons</h1>

</div>
<script>
    let timeSpentOnActualCanvasDraw = 0;

    const GLOBAL_COLOUR_MAP = [];
    let globalMapBuilt = false;

    class AsIsArrayWrapper {
        constructor(arrayToWrap) {
            this.wrappedArray = arrayToWrap;
            this.length = this.wrappedArray.length;
        }

        size() {
            return this.length;
        }

        get(index) {
            return this.wrappedArray[index];
        }

        set(value, index) {
            this.wrappedArray[index] = value;
        }
    }

    class CanvasArrayWrapper {
        constructor(canvasDataArray, from, to, i) {
            if (from < 0) {
                console.error("fuck you 1");
            }
            if (to > canvasDataArray.length - 4) {
                console.error("fuck you 2");
            }
            if (from > to) {
                console.error("fuck you 3");
            }
            this.length = to - from;
            if ((this.length % 4) !== 0) {
                console.error("fuck you 4");
            }
            this.canvasDataArray = canvasDataArray;
            this.from = from;
            this.to = to;
            this.length = this.length / 4 + 1;
        }

        size() {
            return this.length;
        }

        set(colourValue, index) {
            const offset = this.from + index * 4;
            this.canvasDataArray[offset] = colourValue.red;
            this.canvasDataArray[offset + 1] = colourValue.green;
            this.canvasDataArray[offset + 2] = colourValue.blue;
            //this.canvasDataArray[offset + 3] = 255;
        }

        get(index) {
            const offset = this.from + index * 4;
            const red = this.canvasDataArray[offset];
            const green = this.canvasDataArray[offset + 1];
            const blue = this.canvasDataArray[offset + 2];
            return GLOBAL_COLOUR_MAP[red][green][blue];
        }
    }

    class SorterSummary {

        constructor(name, constructorMethod, description) {
            this.name = name;
            this.constructorMethod = constructorMethod;
            this.description = description;
        }
    }


    class BubbleSorter {
        constructor(wrappedArrayToSort, comparator) {
            this.arr = wrappedArrayToSort;
            this.comparator = comparator;
            this.reset();
        }

        reset() {
            this.patientInd = 0;
        }

        oneTick() {
            for (let i = this.patientInd + 1; i < this.arr.size() - 1; i++) {
                let patient = this.arr.get(this.patientInd);
                let toComp = this.arr.get(i + 1);
                if (this.comparator(patient, toComp) > 0) {
                    this.arr.set(toComp, this.patientInd);
                    this.arr.set(patient, i + 1);
                    return true;
                }
            }
            this.patientInd += 1;
            return this.patientInd === this.arr.size() - 1;
        }
    }

    class InsertionSorter {
        constructor(wrappedArrayToSort, comparator) {
            this.arr = wrappedArrayToSort;
            this.comparator = comparator;
        }

        reset() {
            this.patientInd = -1;
        }

        oneTick() {
            for (let i = this.patientInd + 1; i < this.arr.size() - 1; i++) {
                let patient = this.arr.get(i);
                let toComp = this.arr.get(i + 1);
                if (this.comparator(patient, toComp) > 0) {
                    this.arr.set(toComp, i);
                    this.arr.set(patient, i + 1);
                    return true;
                }
            }
            this.patientInd += 1;
            return this.patientInd === this.arr.size() - 1;
        }
    }


    class Slice {
        constructor(low, high) {
            this.low = low;
            this.high = high;
            this.i = null;
            this.j = null;
            this.midElem = null;
        }
    }

    class QuickSorter {

        constructor(wrappedArrayToSort, comparator) {
            this.arr = wrappedArrayToSort;
            this.comparator = comparator;
            this.reset();
        }

        reset() {
            this.slicesToSort = [new Slice(0, this.arr.size() - 1)];
        }

        oneTick() {
            while (this.slicesToSort.length > 0) {
                let slice = this.slicesToSort.pop();
                if (slice.low < slice.high) {
                    let midElem = slice.midElem || this.arr.get(Math.floor(slice.low + (slice.high - slice.low) / 2));
                    slice.midElem = midElem;
                    let i = slice.i || slice.low;
                    let j = slice.j || slice.high;
                    while (i <= j) {
                        while (this.comparator(this.arr.get(i), midElem) < 0) {
                            i++;
                        }
                        while (this.comparator(this.arr.get(j), midElem) > 0) {
                            j--;
                        }
                        if (i <= j) {
                            let tmp = this.arr.get(i);
                            this.arr.set(this.arr.get(j), i);
                            this.arr.set(tmp, j);
                            slice.i = i + 1;
                            slice.j = j - 1;
                            this.slicesToSort.push(slice);
                            return true;
                        }
                    }
                    if (slice.low < j) {
                        this.slicesToSort.push(new Slice(slice.low, j));
                    }
                    if (slice.high > i) {
                        this.slicesToSort.push(new Slice(i, slice.high));
                    }
                    //shuffle(this.slicesToSort)
                }
            }
            return false;
        }
    }


    class PartToMerge {
        constructor(low, high) {
            this.low = low;
            this.high = high;
            this.len = high - low;
        }

        hasSomething() {
            return this.low < this.high;
        }
    }

    class MergeSorter {
        constructor(wrappedArrayToSort, comparator) {
            this.arr = wrappedArrayToSort;
            this.comparator = comparator;
            this.reset();
        }

        reset() {
            this.partsToMerge = [];
            this.persistingInProgress = false;
            this.sortedPartReadyToBePersisted = [];
            this.mainArrayPointer = null;
            for (let i = 0; i < this.arr.size(); i++) {
                this.partsToMerge.push(new PartToMerge(i, i + 1));
            }
        }

        oneTick() {
            if (this.sortedPartReadyToBePersisted.length > 0) {
                const elem = this.sortedPartReadyToBePersisted.shift();
                this.arr.set(elem, this.mainArrayPointer++);
                return true;
            } else {
                while (this.partsToMerge.length > 1) {
                    let right = this.partsToMerge.pop();
                    let left = this.partsToMerge.pop();
                    if (right.len < left.len) {
                        if (this.partsToMerge.length > 0) {
                            this.partsToMerge.unshift(right);
                            right = left;
                            left = this.partsToMerge.pop();
                        }
                    }
                    const newLow = Math.min(left.low, right.low);
                    const newHigh = newLow + left.len + right.len;
                    while (left.hasSomething() && right.hasSomething()) {
                        let fromTheLeft = this.arr.get(left.low);
                        let fromTheRight = this.arr.get(right.low);
                        if (this.comparator(fromTheLeft, fromTheRight) < 0) {
                            this.sortedPartReadyToBePersisted.push(fromTheLeft);
                            left.low++;
                        } else {
                            this.sortedPartReadyToBePersisted.push(fromTheRight);
                            right.low++;
                        }
                    }
                    while (left.hasSomething()) {
                        this.sortedPartReadyToBePersisted.push(this.arr.get(left.low++));
                    }
                    while (right.hasSomething()) {
                        this.sortedPartReadyToBePersisted.push(this.arr.get(right.low++));
                    }
                    this.mainArrayPointer = newLow;
                    this.partsToMerge.unshift(new PartToMerge(newLow, newHigh));
                    return true;
                }
            }
            return false;
        }
    }


    class HeapSorter {

        constructor(wrappedArrayToSort, comparator) {
            this.arr = wrappedArrayToSort;
            this.comparator = comparator;
            this.reset();
        }

        reset() {
            this.heapPreparationDone = false;
            this.heapSortingSwapJustDone = false;
            this.heapSize = this.arr.size();
            this.heapSortingI = this.arr.size() - 1;
            this.heapPreparationI = Math.floor(this.arr.size() / 2);
            this.heapNextMax = this.heapPreparationI;
        }

        oneTick() {
            if (!this.heapPreparationDone) {
                if (this.heapPreparationI <= 0 && this.heapNextMax === null) {
                    this.heapPreparationDone = true;
                } else {
                    if (this.heapNextMax === null) {
                        this.heapNextMax = --this.heapPreparationI
                    }
                    this.heapNextMax = this.sortHeapFrom(this.arr, this.heapNextMax, this.heapSize);
                    return true;
                }
            }
            if (this.heapSortingI > 0) {
                if (this.heapSortingSwapJustDone) {
                    if (this.heapNextMax === null) {
                        this.heapNextMax = 0;
                        --this.heapSize;
                    }
                    this.heapNextMax = this.sortHeapFrom(this.arr, this.heapNextMax, this.heapSize);
                    if (this.heapNextMax !== null) {
                        return true;
                    }
                    this.heapSortingI--;
                    this.heapSortingSwapJustDone = false;
                    return true;
                } else {
                    HeapSorter.swap(this.arr, 0, this.heapSortingI);
                    this.heapSortingSwapJustDone = true;
                    return true;
                }
            }
            return false;
        }

        sortHeapFrom(arr, nextMax, heapLength) {
            let left = 2 * nextMax + 1;
            let right = 2 * nextMax + 2;
            let max = nextMax;
            if (left < heapLength && this.comparator(arr.get(left), arr.get(max)) > 0) {
                max = left;
            }
            if (right < heapLength && this.comparator(arr.get(right), arr.get(max)) > 0) {
                max = right;
            }
            if (max !== nextMax) {
                HeapSorter.swap(arr, nextMax, max);
                return max;
            }
            return null;
        }

        static swap(arr, i, j) {
            let tmp = arr.get(i);
            arr.set(arr.get(j), i);
            arr.set(tmp, j);
        }
    }

    function shuffle(a) {
        for (let i = a.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [a[i], a[j]] = [a[j], a[i]];
        }
    }


    const allSorters = [
        new SorterSummary(
            "Bubble Sort",
            function (array, comparator) {
                return new BubbleSorter(array, comparator);
            },
            "This is a basic bubble sort impl."),
        new SorterSummary(
            "Insertion Sort",
            function (array, comparator) {
                return new InsertionSorter(array, comparator);
            },
            "This is a basic insertion sort impl."),

        new SorterSummary(
            "Merge Sort",
            function (array, comparator) {
                return new MergeSorter(array, comparator);
            },
            "This is a strange version of a merge sort which commits every merge result back to the source array."),
        new SorterSummary(
            "Quick Sort",
            function (array, comparator) {
                return new QuickSorter(array, comparator);
            },
            "This is a basic implementation of the quick sort"),
        new SorterSummary(
            "Heap Sort",
            function (array, comparator) {
                return new HeapSorter(array, comparator);
            },
            "This is a heap sort implementation.")
    ];


    const mainBlock = document.getElementById("mainBlock");

    const maxColourValue = 255;
    const maxCanvasWidth = maxColourValue * 5;
    const documentWidth = document.documentElement.clientWidth;
    const step = Math.max(1, Math.ceil(maxCanvasWidth / documentWidth));
    const canvasWidth = Math.round(maxCanvasWidth / step);
    const DEFAULT_COLOUR_COMP = function (c1, c2) {
        return c1.compare(c2);
    };

    class Colour {

        constructor(red, green, blue) {
            this.red = Colour.to255Range(red);
            this.green = Colour.to255Range(green);
            this.blue = Colour.to255Range(blue);
            this.hue = Colour.getWikiHue(this);
        }

        static to255Range(n) {
            return Math.max(Math.min(n, 255), 0);
        }

        static randomColour() {
            function pizde() {
                return Math.ceil(Math.random() * 255);
            }

            return new Colour(pizde(), pizde(), pizde());
        }


        static getWikiHue(colour) {
            const R = colour.red;
            const G = colour.green;
            const B = colour.blue;

            if (R >= G && G >= B) {
                //return 60 * (G - B) / (R - B);
                return 60 * G / R;
            }
            if (G > R && R >= B) {
                return 60 * (2 - (R - B) / (G - B));
            }
            if (G >= B && B > R) {
                return 60 * (2 + (B - R) / (G - R));
            }
            if (B > G && G > R) {
                return 60 * (4 - (G - R) / (B - R));
            }
            if (B > R && R >= G) {
                return 60 * (4 + (R - G) / (B - G));
            }
            if (R >= B && B > G) {
                return 60 * (6 - (B - G) / (R - G));
            }
        }

        equals(other) {
            return this.red === other.red && this.green === other.green && this.blue === other.blue;

        }

        compare(other) {
            return this.hue - other.hue;
        }
    }


    function REGISTER_ALL_THE_SHIT(sorterCanvas, constructorMethod, canvasWidth, canvasHeight, step) {
        let matrix = generateColourMatrix(canvasWidth, canvasHeight, step);
        cacheColourObjects(matrix[0]);
        matrix.id = sorterCanvas.id + " matrix";
        let sorted = true;
        let statusText;
        const ctx = sorterCanvas.getContext("2d");
        const imageData = ctx.getImageData(0, 0, sorterCanvas.width, canvasHeight);
        const actualData = imageData.data;
        const targetFps = 60;
        const redrawEvery = 1;

        let numberOfTicks = 0;
        let totalTimeSpent = 0;
        let timeSpentOnDraw = 0;
        let drawCalls = 0;

        function DRAW() {
            drawCalls++;
            let beforeDraw = new Date();
            drawColourMatrix(matrix, ctx, imageData, actualData, canvasWidth);
            if (statusText) drawStatusText(ctx, statusText, canvasWidth);
            let afterDraw = new Date();
            timeSpentOnDraw += (afterDraw - beforeDraw);
        }

        function drawStatusText(ctx, textToDraw, canvasWidth) {


            ctx.fillStyle = "white";
            ctx.font = "bold 50px serif ";
            let textMeasurements = ctx.measureText(textToDraw);
            ctx.fillText(statusText, canvasWidth - textMeasurements.width - 15, 50);

        }


        let sorters = [];
        for (let i = 0; i < matrix.length; i++) {
            sorters.push(constructorMethod(new CanvasArrayWrapper(actualData, 4 * i * canvasWidth, 4 * i * canvasWidth + canvasWidth * 4 - 4), DEFAULT_COLOUR_COMP));
        }

        let sortStarted = false;
        let justACounter = 0;
        let fastForwardingDelay = -1;
        let chainedTick = function () {
            if (!sortStarted) {
                statusText = "Paused";
                stopReDraw();
                console.log("number of ticks:", numberOfTicks);
                console.log("time spent on tick", totalTimeSpent, numberOfTicks, totalTimeSpent / numberOfTicks);
                console.log("time spent on draw", timeSpentOnDraw, timeSpentOnDraw / drawCalls);
                console.log("time spent on CANVAS", timeSpentOnActualCanvasDraw, timeSpentOnActualCanvasDraw / drawCalls);
                return;
            }
            let somethingChanged = false;
            let beforeTick = new Date();
            do {
                for (let i = 0; i < sorters.length; i++) {
                    if (fastForwardingDelay > 0) {
                        for (let kkk = 0; kkk < 50; kkk++) {
                            somethingChanged = sorters[i].oneTick() || somethingChanged;
                        }
                    } else {
                        somethingChanged = sorters[i].oneTick() || somethingChanged;
                    }
                }
            } while (new Date() - beforeTick < fastForwardingDelay);
            drawAtOnce = 1;
            let afterTick = new Date();
            totalTimeSpent += (afterTick - beforeTick);
            numberOfTicks++;
            if (!somethingChanged) {
                console.log("Sorted");
                statusText = "All Sorted";
                console.log("number of ticks:", numberOfTicks);
                console.log("total time: ", totalTimeSpent, totalTimeSpent / numberOfTicks);
                console.log("time spent on draw", timeSpentOnDraw, timeSpentOnDraw / drawCalls);
                console.log("time spent on CANVAS", timeSpentOnActualCanvasDraw, timeSpentOnActualCanvasDraw / drawCalls);
                sorted = true;
                sortStarted = false;
                stopReDraw();
            } else {
                justACounter++;
                if (justACounter % redrawEvery === 0) {
                    hasSomethingToDraw = true;
                    //setTimeout(chainedTick, 1500 / targetFps);
                    DRAW();
                } else {
                    //chainedTick();
                }
                window.requestAnimationFrame(chainedTick);

            }
        };
        let reDrawInterval;
        let hasSomethingToDraw = true;

        function stopReDraw() {
            DRAW();
            clearInterval(reDrawInterval);
        }

        function registerReDraw() {
            stopReDraw();
            let fps = targetFps;
            if (fps === 0) {
                return;
            }
            let delay = 1000 / fps;
            //console.log("REGISTERING REDRAW: ", fps, delay);
            reDrawInterval = setInterval(function () {
                if (hasSomethingToDraw) {
                    DRAW();
                    hasSomethingToDraw = false;
                }
            }, delay);

        }

        function registerRequestFrameChainedRedraw() {
            if (hasSomethingToDraw) {
                DRAW();
                hasSomethingToDraw = false;
            }
            window.requestAnimationFrame(registerRequestFrameChainedRedraw);
        }

        function shuffleTheStuff() {
            for (let i = 0; i < matrix.length; i++) {
                shuffle(matrix[i]);
                sorters[i].reset();
            }
            sorted = false;
            statusText = "Shuffled"
        }

        shuffleTheStuff();
        statusText = "Click me";
        putMatrixToCanvasData(matrix, actualData, canvasWidth);
        DRAW();
        let regularClick = function () {
            if (sorted) {
                shuffleTheStuff();
                putMatrixToCanvasData(matrix, actualData, canvasWidth);
                DRAW();
            } else if (sortStarted) {
                sortStarted = false;
            } else {
                console.log("starting sort");
                statusText = "Sorting";
                sortStarted = true;
                chainedTick();
            }
        };

        //sorterCanvas.onclick = regularClick;
        let lastTimeStamp = -1;
        let forwardingTimeout = -1;
        let statusBeforeFastForwarding;
        let ON_DOWN = function (_event) {
            lastTimeStamp = _event.timeStamp;
            forwardingTimeout = setTimeout(function () {
                console.log("START THE SHIT");
                statusBeforeFastForwarding = statusText;
                statusText = "Fast forwarding";
                fastForwardingDelay = 1000;
            }, 1000);
            console.log("onmouse DOWN!!~!!!!!!!", _event.timeStamp);
            _event.preventDefault();
        };
        sorterCanvas.onmousedown = ON_DOWN;
        let ON_UP = function (_event) {
            console.log("onmouse up~!!!!!!!", _event.timeStamp);
            if (_event.timeStamp - lastTimeStamp > 1000) {
                console.log("stop the shit");
                statusText = statusBeforeFastForwarding;
                fastForwardingDelay = -1;
            } else {
                clearTimeout(forwardingTimeout);
                regularClick();
            }
            _event.preventDefault();
        };
        sorterCanvas.onmouseup = ON_UP;
        sorterCanvas.ontouchstart = ON_DOWN;
        sorterCanvas.ontouchend = ON_UP;
    }

    allSorters.forEach(function (ss) {

        let sorterDiv = document.createElement('div');

        sorterDiv.id = ss.name + "-" + ss.name;
        let sorterName = document.createElement('h3');
        sorterName.innerHTML = ss.name;
        let sorterDescription = document.createElement('label');
        sorterDescription.innerHTML = ss.description;
        let br = document.createElement('br');

        const canvasHeight = Math.ceil(canvasWidth / 2);
        let sorterCanvas = document.createElement('canvas');
        sorterCanvas.id = ss.name + "CanvasId";
        sorterCanvas.width = canvasWidth;
        sorterCanvas.height = canvasHeight;
        sorterCanvas.innerHTML = "There should be HTML canvas with a pretty animation, but fuck you."

        sorterDiv.appendChild(sorterName);
        sorterDiv.appendChild(sorterDescription);
        sorterDiv.appendChild(br);
        sorterDiv.appendChild(sorterCanvas);
        mainBlock.appendChild(sorterDiv);

        REGISTER_ALL_THE_SHIT(sorterCanvas, ss.constructorMethod, canvasWidth, canvasHeight, step);
    });


    function applyStep(vals, steps, wasOnLims, pos, step, maxTimes) {
        vals[pos] += steps[pos];
        if (vals[pos] >= maxColourValue) {
            if (wasOnLims[pos] < maxTimes) {
                wasOnLims[pos]++;
                steps[pos] = 0;
            } else {
                wasOnLims[pos] = 0;
                steps[pos] = -step;
            }
        } else if (vals[pos] <= 0) {
            if (wasOnLims[pos] < maxTimes) {
                wasOnLims[pos]++;
                steps[pos] = 0;
            } else {
                wasOnLims[pos] = 0;
                steps[pos] = step;
            }
        }
    }

    function generateColourMatrix(width, height, step) {

        const rows = height;
        const columns = width;
        const maxTimes = maxColourValue / step;
        let colourMatrix = [];

        for (let i = 0; i < rows; i++) {
            let row = [];
            let currentSteps = [step, step, -step];
            let currentColorVals = [maxColourValue, 0, 0];
            let wasOnLimTimes = [0, maxTimes, maxTimes];
            for (let j = 0; j < columns; j++) {

                row.push(new Colour(currentColorVals[0], currentColorVals[1], currentColorVals[2]));
                applyStep(currentColorVals, currentSteps, wasOnLimTimes, 0, step, maxTimes);
                applyStep(currentColorVals, currentSteps, wasOnLimTimes, 1, step, maxTimes);
                applyStep(currentColorVals, currentSteps, wasOnLimTimes, 2, step, maxTimes);
            }
            colourMatrix.push(row);
        }
        return colourMatrix;
    }

    function cacheColourObjects(colours) {
        if (!globalMapBuilt) {
            for (let i = 0; i < colours.length; i++) {
                ADD_TO_GLOBAL_MAP(colours[i]);
            }
            globalMapBuilt = true;
        }
    }

    function ADD_TO_GLOBAL_MAP(colour) {
        if (!GLOBAL_COLOUR_MAP[colour.red]) {
            GLOBAL_COLOUR_MAP[colour.red] = [];
        }
        if (!GLOBAL_COLOUR_MAP[colour.red][colour.green]) {
            GLOBAL_COLOUR_MAP[colour.red][colour.green] = [];
        }
        GLOBAL_COLOUR_MAP[colour.red][colour.green][colour.blue] = colour;
    }

    function drawColourMatrix(matrix, canvasCtx, imageData, actualData, canvasWidth) {
        let beforePut = new Date();
        canvasCtx.putImageData(imageData, 0, 0);
        let afterPut = new Date();
        timeSpentOnActualCanvasDraw += (afterPut - beforePut);

    }

    function putMatrixToCanvasData(matrix, actualData, canvasWidth) {
        for (let i = 0; i < matrix.length; i++) {
            let row = matrix[i];
            for (let j = 0; j < row.length; j++) {
                let col = row[j];
                let offset = (i * canvasWidth) * 4 + j * 4;
                actualData[offset] = col.red;
                actualData[offset + 1] = col.green;
                actualData[offset + 2] = col.blue;
                actualData[offset + 3] = 255;
            }
        }
    }


</script>

</body>
</html>
