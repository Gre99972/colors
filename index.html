<!DOCTYPE html>
<html>
<head>
    <script type="text/javascript" src="Colour.js"></script>
    <script type="text/javascript" src="sorters/BubbleSorter.js"></script>
    <script type="text/javascript" src="sorters/InsertionSorter.js"></script>
    <script type="text/javascript" src="sorters/MergeSorter.js"></script>
    <script type="text/javascript" src="sorters/HeapSorter.js"></script>
    <script type="text/javascript" src="sorters/QuickSorter.js"></script>
    <script type="text/javascript" src="utils-slash-hacks/ArrayUtils.js"></script>
    <script type="text/javascript" src="utils-slash-hacks/DebugUtils.js"></script>
    <title>ðŸŒˆSorting algorithmsðŸ¤¤</title>
</head>
<body>
<div id="mainBlock">

    <h1>Sorting algorithms swap comparisons</h1>
    <input id="statusTextCheckbox" type="checkbox" checked/><label>Status text</label>
    <input id="debugInfoCheckbox" type="checkbox" checked/><label>Debug info</label>

</div>
<script>

    const GLOBAL_COLOUR_MAP = [];
    let globalMapBuilt = false;

    class SorterSummary {

        constructor(name, constructorMethod, description) {
            this.name = name;
            this.constructorMethod = constructorMethod;
            this.description = description;
        }
    }

    const allSorters = [
    /*
        new SorterSummary(
            "Bubble Sort",
            function (array, comparator) {
                return new BubbleSorter(array, comparator);
            },
            "This is a basic bubble sort impl."),
        new SorterSummary(
            "Insertion Sort",
            function (array, comparator) {
                return new InsertionSorter(array, comparator);
            },
            "This is a basic insertion sort impl."),

        new SorterSummary(
            "Merge Sort",
            function (array, comparator) {
                return new MergeSorter(array, comparator);
            },
            "This is a strange version of a merge sort which commits every merge result back to the source array."),
        */
        new SorterSummary(
            "Quick Sort",
            function (array, comparator) {
                return new QuickSorter(array, comparator);
            },
            "This is a basic implementation of the quick sort"),
        new SorterSummary(
            "Heap Sort",
            function (array, comparator) {
                return new HeapSorter(array, comparator);
            },
            "This is a heap sort implementation.")
    ];


    const mainBlock = document.getElementById("mainBlock");
    const statusTextCheckbox = document.getElementById("statusTextCheckbox");
    const debugInfoCheckbox = document.getElementById("debugInfoCheckbox");

    const maxColourValue = 255;
    const canvasWidth_GIVNO = mainBlock.offsetWidth;
    const step = maxColourValue * 5 / canvasWidth_GIVNO;

    const DEFAULT_COLOUR_COMP = function (c1, c2) {
        return c1.compare(c2);
    };

    function REGISTER_ALL_THE_SHIT(sorterCanvas, constructorMethod, canvasWidth, canvasHeight, scaledWidth, scaledHeight, step) {
        let matrix = generateColourMatrix(scaledWidth, scaledHeight, step);
        cacheColourObjects(matrix[0]);
        matrix.id = sorterCanvas.id + " matrix";
        let sorted = true;
        let statusText;
        const ctx = sorterCanvas.getContext("2d");
        const imageData = ctx.getImageData(0, 0, scaledWidth, scaledHeight);
        const actualData = imageData.data;
        const debugInfoObject = new DebugInfo("pahui zeleni");

        function DRAW() {
            debugInfoObject.beginDraw();
            drawColourMatrix(matrix, ctx, imageData, actualData, scaledWidth);
            debugInfoObject.endDraw();
            if (statusText && statusTextCheckbox.checked) drawStatusText(ctx, statusText, canvasWidth);
            if (debugInfoCheckbox.checked) drawDebugStats(ctx, debugInfoObject, canvasWidth, canvasHeight);
        }

        function drawStatusText(ctx, textToDraw, canvasWidth) {
            ctx.fillStyle = "white";
            ctx.font = "bold 50px serif ";
            let textMeasurements = ctx.measureText(textToDraw);
            ctx.fillText(statusText, canvasWidth - textMeasurements.width - 15, 50);
        }

        function drawDebugStats(ctx, debugInfo, canvasWidth, canvasHeight) {
            let debugRectangleWidth = 200;
            let debugRectangleHeight = 120;
            let x = canvasWidth - debugRectangleWidth;
            let y = canvasHeight - debugRectangleHeight;
            ctx.fillStyle = 'rgba(5, 5, 5, 0.5)';
            ctx.fillRect(x, y, debugRectangleWidth, debugRectangleHeight);

            ctx.fillStyle = "white";
            ctx.font = "bold 15px serif ";


            let timeSpent = debugInfo.currentTotalTime();
            let millisecondsInMinute = 1000 * 60;
            let timeSpentFormatted = "Time spent: "
                + Math.floor(timeSpent / (millisecondsInMinute)) + " min "
                + Number((timeSpent % (millisecondsInMinute))/ 1000).toFixed(1) + " sec ";
            ctx.fillText(timeSpentFormatted, x + 10, y + 20, debugRectangleWidth);

            let totalDrawCalls = "Total draw calls: " + debugInfo.numberOfDrawCalls;
            ctx.fillText(totalDrawCalls, x + 10, y + 35, debugRectangleWidth);

            let currentFps = "Current FPS: " + debugInfo.currentFps();
            ctx.fillText(currentFps, x + 10, y + 50, debugRectangleWidth);

            let avgDrawCallDuration = "Avg Draw time: "  + Number(debugInfo.avgDrawCallDuration).toFixed(2) + "ms";
            ctx.fillText(avgDrawCallDuration, x + 10, y + 65, debugRectangleWidth);

            let avgTickDuration = "Avg Sort time: " + Number(debugInfo.avgTickDuration).toFixed(2) + "ms";
            ctx.fillText(avgTickDuration, x + 10, y + 80, debugRectangleWidth);

            let avgFps = "Avg FPS: " + Number(debugInfo.numberOfDrawCalls * 1000 / timeSpent).toFixed(2);
            ctx.fillText(avgFps, x + 10, y + 95, debugRectangleWidth);

            let mem = window.performance.memory;
            let currentJSHeapSize = "JS Heap Size: " + ((mem && mem.usedJSHeapSize) ? Number(mem.usedJSHeapSize / 1024 / 1024).toFixed(2) : "??") + "MB";
            ctx.fillText(currentJSHeapSize, x + 10, y + 110, debugRectangleWidth);
        }

        let sorters = [];
        for (let i = 0; i < matrix.length; i++) {
            sorters.push(constructorMethod(new CanvasArrayWrapper(actualData, 4 * i * scaledWidth, 4 * i * scaledWidth + scaledWidth * 4 - 4), DEFAULT_COLOUR_COMP));
        }

        let sortStarted = false;
        let chainedTick = function () {
            if (!sortStarted) {
                DRAW();
                return;
            }
            let somethingChanged = false;
            debugInfoObject.beginTick();
            for (let i = 0; i < sorters.length; i++) {
                somethingChanged = sorters[i].oneTick() || somethingChanged;
            }
            debugInfoObject.endTick();
            if (!somethingChanged) {
                statusText = "All Sorted";
                sorted = true;
                sortStarted = false;
                DRAW();
            } else {
                DRAW();
                window.requestAnimationFrame(chainedTick);
            }
        };

        function shuffleTheStuff() {
            for (let i = 0; i < matrix.length; i++) {
                shuffle(matrix[i]);
                sorters[i].reset();
            }
            sorted = false;
            statusText = "Shuffled"
        }

        shuffleTheStuff();
        statusText = "Click me";
        putMatrixToCanvasData(matrix, actualData, scaledWidth);
        DRAW();
        let regularClick = function () {
            if (sorted) {
                shuffleTheStuff();
                debugInfoObject.reset();
                putMatrixToCanvasData(matrix, actualData, scaledWidth);
                DRAW();
            } else if (sortStarted) {
                statusText = "Paused";
                debugInfoObject.stop();
                sortStarted = false;
            } else {
                statusText = "Sorting";
                sortStarted = true;
                debugInfoObject.start();
                chainedTick();
            }
        };
        sorterCanvas.onclick = regularClick;
    }

    allSorters.forEach(function (ss) {

        let sorterDiv = document.createElement('div');

        sorterDiv.id = ss.name + "-" + ss.name;
        let sorterName = document.createElement('h3');
        sorterName.innerHTML = ss.name;
        let sorterDescription = document.createElement('label');
        sorterDescription.innerHTML = ss.description;
        let br = document.createElement('br');

        const canvasHeight = Math.ceil(canvasWidth_GIVNO / 2.2);
        let sorterCanvas = document.createElement('canvas');
        sorterCanvas.id = ss.name + "CanvasId";
        sorterCanvas.width = canvasWidth_GIVNO;
        sorterCanvas.height = canvasHeight;
        sorterCanvas.innerHTML = "There should be HTML canvas with a pretty animation, but fuck you.";

        const originalCanvasWidth = sorterCanvas.width;
        const originalCanvasHeight = sorterCanvas.height;
        let ctx = sorterCanvas.getContext("2d");
        if (window.devicePixelRatio > 1) {
            sorterCanvas.width = originalCanvasWidth * window.devicePixelRatio;
            sorterCanvas.height = originalCanvasHeight * window.devicePixelRatio;
            //console.log("before", sorterCanvas.style);
            sorterCanvas.setAttribute("style", "width:" + originalCanvasWidth + "px");
            //console.log("after", sorterCanvas.style.width);

            sorterCanvas.setAttribute("style", "height:" + originalCanvasHeight + "px");

            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }
        const scaledCanvasWidth = originalCanvasWidth * window.devicePixelRatio;
        const scaledCanvasHeight = originalCanvasHeight * window.devicePixelRatio;

        sorterDiv.appendChild(sorterName);
        sorterDiv.appendChild(sorterDescription);
        sorterDiv.appendChild(br);
        sorterDiv.appendChild(sorterCanvas);
        mainBlock.appendChild(sorterDiv);

        REGISTER_ALL_THE_SHIT(sorterCanvas, ss.constructorMethod, originalCanvasWidth, originalCanvasHeight, scaledCanvasWidth, scaledCanvasHeight, step);
    });


    function generateColourMatrix(width, height, step) {

        const rows = height;
        const columns = width;
        let colourMatrix = [];

        const D_UP = 0;
        const D_DOWN = 1;
        const D_TOP = 2;
        const D_BOTTOM = 3;
        const D_THE_MOST_BOTTOM = 4;
        const MAX_STEPS = maxColourValue / step;

        class ColorState {
            constructor(colorVal, direction, stepsDone) {
                this.colorVal = colorVal;
                this.direction = direction;
                this.stepsDone = stepsDone;
            }
        }

        let referenceRow = [];

        let red = new ColorState(maxColourValue, D_TOP, 0);
        let green = new ColorState(0, D_UP, 0);
        let blue = new ColorState(0, D_THE_MOST_BOTTOM, 0);
        let allTogether = [red, green, blue];
        for (let j = 0; j < columns; j++) {
            referenceRow.push(new Colour(red.colorVal, green.colorVal, blue.colorVal));
            allTogether.forEach(function (c) {
                if (c.stepsDone >= MAX_STEPS) {
                    switch (c.direction) {
                        case D_BOTTOM:
                            c.direction = D_UP;
                            break;
                        case D_TOP:
                            c.direction = D_DOWN;
                            break;
                        case D_UP:
                            c.direction = D_TOP;
                            break;
                        case D_DOWN:
                            c.direction = D_BOTTOM;
                            break;
                        case D_THE_MOST_BOTTOM:
                            c.direction = D_BOTTOM;
                            break;
                    }
                    c.stepsDone = 0;
                }
                switch (c.direction) {
                    case D_BOTTOM:
                        break;
                    case D_TOP:
                        break;
                    case D_UP:
                        c.colorVal += step;
                        break;
                    case D_DOWN:
                        c.colorVal -= step;
                        break;
                    case D_THE_MOST_BOTTOM:
                        break;
                }
                c.stepsDone++;
            });
        }
        for (let i = 0; i < rows; i++) {
            let newRow = [];
            for (let k = 0; k < referenceRow.length; k++) {
                let c = referenceRow[k];
                newRow.push(new Colour(c.red, c.green, c.blue));
            }
            colourMatrix.push(newRow);
        }
        return colourMatrix;
    }

    function cacheColourObjects(colours) {
        if (!globalMapBuilt) {
            for (let i = 0; i < colours.length; i++) {
                ADD_TO_GLOBAL_MAP(colours[i]);
            }
            globalMapBuilt = true;
        }
    }

    function ADD_TO_GLOBAL_MAP(colour) {
        if (!GLOBAL_COLOUR_MAP[colour.red]) {
            GLOBAL_COLOUR_MAP[colour.red] = [];
        }
        if (!GLOBAL_COLOUR_MAP[colour.red][colour.green]) {
            GLOBAL_COLOUR_MAP[colour.red][colour.green] = [];
        }
        GLOBAL_COLOUR_MAP[colour.red][colour.green][colour.blue] = colour;
    }

    function drawColourMatrix(matrix, canvasCtx, imageData, actualData, canvasWidth) {
        canvasCtx.putImageData(imageData, 0, 0);
    }

    function putMatrixToCanvasData(matrix, actualData, canvasWidth) {
        for (let i = 0; i < matrix.length; i++) {
            let row = matrix[i];
            for (let j = 0; j < row.length; j++) {
                let col = row[j];
                let offset = (i * canvasWidth) * 4 + j * 4;
                actualData[offset] = col.red;
                actualData[offset + 1] = col.green;
                actualData[offset + 2] = col.blue;
                actualData[offset + 3] = 255;
            }
        }
    }



</script>

</body>
</html>
