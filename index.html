<!DOCTYPE html>
<html>
<head>
<script>
        class Colour {
    constructor(red, green, blue) {
        this.red = Colour.to255Range(red);
        this.green = Colour.to255Range(green);
        this.blue = Colour.to255Range(blue);
        this.hue = Colour.getWikiHue(this);
    }
    static to255Range(n) {
        return Math.ceil(Math.max(Math.min(n, 255), 0));
    }
    static getWikiHue(colour) {
        const R = colour.red;
        const G = colour.green;
        const B = colour.blue;
        if (R >= G && G >= B) {
            //return 60 * (G - B) / (R - B);
            return 60 * G / R;
        }
        if (G > R && R >= B) {
            return 60 * (2 - (R - B) / (G - B));
        }
        if (G >= B && B > R) {
            return 60 * (2 + (B - R) / (G - R));
        }
        if (B > G && G > R) {
            return 60 * (4 - (G - R) / (B - R));
        }
        if (B > R && R >= G) {
            return 60 * (4 + (R - G) / (B - G));
        }
        if (R >= B && B > G) {
            return 60 * (6 - (B - G) / (R - G));
        }
    }
    equals(other) {
        return this.red === other.red && this.green === other.green && this.blue === other.blue;
    }
    compare(other) {
        return this.hue - other.hue;
    }
}

const DEFAULT_COLOUR_COMP = function (c1, c2) {
    return c1.compare(c2);
};
        function generateReferenceRow(width, step) {
    const D_UP = 0;
    const D_DOWN = 1;
    const D_TOP = 2;
    const D_BOTTOM = 3;
    const D_THE_MOST_BOTTOM = 4;
    const MAX_STEPS = maxColourValue / step;

    class ColorState {
        constructor(colorVal, direction, stepsDone) {
            this.colorVal = colorVal;
            this.direction = direction;
            this.stepsDone = stepsDone;
        }
    }

    let referenceRow = [];

    let red = new ColorState(maxColourValue, D_TOP, 0);
    let green = new ColorState(0, D_UP, 0);
    let blue = new ColorState(0, D_THE_MOST_BOTTOM, 0);
    let allTogether = [red, green, blue];
    for (let j = 0; j < width; j++) {
        referenceRow.push(new Colour(red.colorVal, green.colorVal, blue.colorVal));
        allTogether.forEach(function (c) {
            if (c.stepsDone >= MAX_STEPS) {
                switch (c.direction) {
                    case D_BOTTOM:
                        c.direction = D_UP;
                        break;
                    case D_TOP:
                        c.direction = D_DOWN;
                        break;
                    case D_UP:
                        c.direction = D_TOP;
                        break;
                    case D_DOWN:
                        c.direction = D_BOTTOM;
                        break;
                    case D_THE_MOST_BOTTOM:
                        c.direction = D_BOTTOM;
                        break;
                }
                c.stepsDone = 0;
            }
            switch (c.direction) {
                case D_BOTTOM:
                    break;
                case D_TOP:
                    break;
                case D_UP:
                    c.colorVal += step;
                    break;
                case D_DOWN:
                    c.colorVal -= step;
                    break;
                case D_THE_MOST_BOTTOM:
                    break;
            }
            c.stepsDone++;
        });
    }
    return referenceRow;
}

function populateColourMatrix(referenceRow, rows) {
    let colourMatrix = [];

    for (let i = 0; i < rows; i++) {
        colourMatrix.push(referenceRow.slice(0));
    }
    return colourMatrix;
}

function drawColourMatrix(matrix, canvasCtx, imageData) {
    canvasCtx.putImageData(imageData, 0, 0);
}

function putMatrixToCanvasData(matrix, actualData, canvasWidth) {
    for (let i = 0; i < matrix.length; i++) {
        let row = matrix[i];
        for (let j = 0; j < row.length; j++) {
            let col = row[j];
            let offset = (i * canvasWidth) * 4 + j * 4;
            actualData[offset] = col.red;
            actualData[offset + 1] = col.green;
            actualData[offset + 2] = col.blue;
            actualData[offset + 3] = 255;
        }
    }
}

function cacheColourObjects(colours, cache) {
    for (let i = 0; i < colours.length; i++) {
        if (!cache[colours[i].red]) {
            cache[colours[i].red] = [];
        }
        if (!cache[colours[i].red][colours[i].green]) {
            cache[colours[i].red][colours[i].green] = [];
        }
        cache[colours[i].red][colours[i].green][colours[i].blue] = colours[i];
    }
}
        class BubbleSorter {
    constructor(arrayToSort, comparator) {
        this.arr = arrayToSort;
        this.comparator = comparator;
        this.reset();
    }

    reset() {
        this.startFromI = 0;
        this.startFromJ = 0;
    }

    oneTick() {
        for (let i = this.startFromI ;i < this.arr.size()-1; i++) {
            let swapDone = false;
            for (let j = this.startFromJ; j < this.arr.size() - i -1; j++) {
                let patient = this.arr.get(j);
                let toComp = this.arr.get(j + 1);
                //console.log("Comparing, ", patient, toComp);
                if (this.comparator(patient, toComp) > 0) {
                    this.arr.set(toComp, j);
                    this.arr.set(patient, j + 1);
                    swapDone = true;
                }
            }
            if (swapDone) {
                this.startFromI = i;
                this.startFromJ = 0;
                return true;
            } else {
                return false;
            }
        }
    }
        }
        class HeapSorter {
    constructor(wrappedArrayToSort, comparator) {
        this.arr = wrappedArrayToSort;
        this.comparator = comparator;
        this.reset();
    }
    reset() {
        this.heapPreparationDone = false;
        this.heapSortingSwapJustDone = false;
        this.heapSize = this.arr.size();
        this.heapSortingI = this.arr.size() - 1;
        this.heapPreparationI = Math.floor(this.arr.size() / 2);
        this.heapNextMax = this.heapPreparationI;
    }
    oneTick() {
        if (!this.heapPreparationDone) {
            if (this.heapPreparationI <= 0 && this.heapNextMax === null) {
                this.heapPreparationDone = true;
            } else {
                if (this.heapNextMax === null) {
                    this.heapNextMax = --this.heapPreparationI
                }
                this.heapNextMax = this.sortHeapFrom(this.arr, this.heapNextMax, this.heapSize);
                return true;
            }
        }
        if (this.heapSortingI > 0) {
            if (this.heapSortingSwapJustDone) {
                if (this.heapNextMax === null) {
                    this.heapNextMax = 0;
                    --this.heapSize;
                }
                this.heapNextMax = this.sortHeapFrom(this.arr, this.heapNextMax, this.heapSize);
                if (this.heapNextMax !== null) {
                    return true;
                }
                this.heapSortingI--;
                this.heapSortingSwapJustDone = false;
                return true;
            } else {
                HeapSorter.swap(this.arr, 0, this.heapSortingI);
                this.heapSortingSwapJustDone = true;
                return true;
            }
        }
        return false;
    }
    sortHeapFrom(arr, nextMax, heapLength) {
        let left = 2 * nextMax + 1;
        let right = 2 * nextMax + 2;
        let max = nextMax;
        if (left < heapLength && this.comparator(arr.get(left), arr.get(max)) > 0) {
            max = left;
        }
        if (right < heapLength && this.comparator(arr.get(right), arr.get(max)) > 0) {
            max = right;
        }
        if (max !== nextMax) {
            HeapSorter.swap(arr, nextMax, max);
            return max;
        }
        return null;
    }
    static swap(arr, i, j) {
        let tmp = arr.get(i);
        arr.set(arr.get(j), i);
        arr.set(tmp, j);
    }
            }
        class InsertionSorter {
    constructor(wrappedArrayToSort, comparator) {
        this.arr = wrappedArrayToSort;
        this.comparator = comparator;
        this.reset();
    }
    reset() {
        this.patientInd = -1;
    }
    oneTick() {
        for (let i = this.patientInd + 1; i < this.arr.size() - 1; i++) {
            let patient = this.arr.get(i);
            let toComp = this.arr.get(i + 1);
            if (this.comparator(patient, toComp) > 0) {
                this.arr.set(toComp, i);
                this.arr.set(patient, i + 1);
                return true;
            }
        }
        this.patientInd += 1;
        return this.patientInd === this.arr.size() - 1;
    }
        }
        class PartToMerge {
    constructor(low, high) {
        this.low = low;
        this.high = high;
        this.len = high - low;
    }
    hasSomething() {
        return this.low < this.high;
    }
}
class MergeSorter {
    constructor(wrappedArrayToSort, comparator) {
        this.arr = wrappedArrayToSort;
        this.comparator = comparator;
        this.reset();
    }
    reset() {
        this.partsToMerge = [];
        this.persistingInProgress = false;
        this.sortedPartReadyToBePersisted = [];
        this.mainArrayPointer = null;
        for (let i = 0; i < this.arr.size(); i++) {
            this.partsToMerge.push(new PartToMerge(i, i + 1));
        }
    }
    oneTick() {
        if (this.sortedPartReadyToBePersisted.length > 0) {
            const elem = this.sortedPartReadyToBePersisted.shift();
            this.arr.set(elem, this.mainArrayPointer++);
            return true;
        } else {
            while (this.partsToMerge.length > 1) {
                let right = this.partsToMerge.pop();
                let left = this.partsToMerge.pop();
                if (right.len < left.len) {
                    if (this.partsToMerge.length > 0) {
                        this.partsToMerge.unshift(right);
                        right = left;
                        left = this.partsToMerge.pop();
                    }
                }
                const newLow = Math.min(left.low, right.low);
                const newHigh = newLow + left.len + right.len;
                while (left.hasSomething() && right.hasSomething()) {
                    let fromTheLeft = this.arr.get(left.low);
                    let fromTheRight = this.arr.get(right.low);
                    if (this.comparator(fromTheLeft, fromTheRight) < 0) {
                        this.sortedPartReadyToBePersisted.push(fromTheLeft);
                        left.low++;
                    } else {
                        this.sortedPartReadyToBePersisted.push(fromTheRight);
                        right.low++;
                    }
                }
                while (left.hasSomething()) {
                    this.sortedPartReadyToBePersisted.push(this.arr.get(left.low++));
                }
                while (right.hasSomething()) {
                    this.sortedPartReadyToBePersisted.push(this.arr.get(right.low++));
                }
                this.mainArrayPointer = newLow;
                this.partsToMerge.unshift(new PartToMerge(newLow, newHigh));
                return true;
            }
        }
        return false;
    }
}
        class Slice {
    constructor(low, high) {
        this.low = low;
        this.high = high;
        this.i = null;
        this.j = null;
        this.midElem = null;
    }
}
class QuickSorter {
    constructor(wrappedArrayToSort, comparator) {
        this.arr = wrappedArrayToSort;
        this.comparator = comparator;
        this.reset();
    }
    reset() {
        this.slicesToSort = [new Slice(0, this.arr.size() - 1)];
    }
    oneTick() {
        while (this.slicesToSort.length > 0) {
            let slice = this.slicesToSort.pop();
            if (slice.low < slice.high) {
                let midElem = slice.midElem || this.arr.get(Math.floor(slice.low + (slice.high - slice.low) / 2));
                slice.midElem = midElem;
                let i = slice.i != null ? slice.i : slice.low;
                let j = slice.j != null ? slice.j : slice.high;
                while (i <= j) {
                    while (this.comparator(this.arr.get(i), midElem) < 0) {
                        i++;
                    }
                    while (this.comparator(this.arr.get(j), midElem) > 0) {
                        j--;
                    }
                    if (i <= j) {
                        let tmp = this.arr.get(i);
                        this.arr.set(this.arr.get(j), i);
                        this.arr.set(tmp, j);
                        slice.i = i + 1;
                        slice.j = j - 1;
                        this.slicesToSort.push(slice);
                        return true;
                    }
                }
                if (slice.low < j) {
                    this.slicesToSort.push(new Slice(slice.low, j));
                }
                if (slice.high > i) {
                    this.slicesToSort.push(new Slice(i, slice.high));
                }
                //shuffle(this.slicesToSort)
            }
        }
        return false;
    }
        }
        class SorterSummary {

    constructor(name, constructorMethod, description, enabled) {
        this.name = name;
        this.constructorMethod = constructorMethod;
        this.description = description;
        this.enabled = enabled;
    }
}

const allSorters = [

    new SorterSummary(
        "Quick Sort",
        function (array, comparator) {
            return new QuickSorter(array, comparator);
        },
        "This is an implementation of the quick sort algorithm. ",
        true
    ),

    new SorterSummary(
        "Heap Sort",
        function (array, comparator) {
            return new HeapSorter(array, comparator);
        },
        "This is an implementation of the heap sort algorithm.",
        true
    ),

    new SorterSummary(
        "Merge Sort",
        function (array, comparator) {
            return new MergeSorter(array, comparator);
        },
        "This is a modified version of the merge sort which commits every merge result back to the source array.",
        false
    ),

    new SorterSummary(
        "Insertion Sort",
        function (array, comparator) {
            return new InsertionSorter(array, comparator);
        },
        "This is an implementation of the insertion sort.",
        false
    ),

    new SorterSummary(
        "Bubble Sort",
        function (array, comparator) {
            return new BubbleSorter(array, comparator);
        },
        "This is an implementation of the bubble sort. For the sake of a more entertaining visualization doesn't show intermediate swaps.",
        false,
    ),



];
        class AsIsArrayWrapper {
    constructor(arrayToWrap) {
        this.wrappedArray = arrayToWrap;
        this.length = this.wrappedArray.length;
    }
    size() {
        return this.length;
    }
    get(index) {
        return this.wrappedArray[index];
    }
    set(value, index) {
        this.wrappedArray[index] = value;
    }
}
class CanvasArrayWrapper {
    constructor(canvasDataArray, from, to, i) {
        if (from < 0) {
            console.error("Error 1");
        }
        if (to > canvasDataArray.length - 4) {
            console.error("Error 2");
        }
        if (from > to) {
            console.error("Error 3");
        }
        this.length = to - from;
        if ((this.length % 4) !== 0) {
            console.error("Error 4");
        }
        this.canvasDataArray = canvasDataArray;
        this.from = from;
        this.to = to;
        this.length = this.length / 4 + 1;
    }
    size() {
        return this.length;
    }
    set(colourValue, index) {
        const offset = this.from + index * 4;
        this.canvasDataArray[offset] = colourValue.red;
        this.canvasDataArray[offset + 1] = colourValue.green;
        this.canvasDataArray[offset + 2] = colourValue.blue;
        //this.canvasDataArray[offset + 3] = 255;
    }
    get(index) {
        const offset = this.from + index * 4;
        const red = this.canvasDataArray[offset];
        const green = this.canvasDataArray[offset + 1];
        const blue = this.canvasDataArray[offset + 2];
        return GLOBAL_COLOUR_MAP[red][green][blue];
    }
}


function shuffle(a) {
    for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
    }
}


//https://stackoverflow.com/questions/7837456/how-to-compare-arrays-in-javascript
// Warn if overriding existing method
if(Array.prototype.equals)
    console.warn("Overriding existing Array.prototype.equals. Possible causes: New API defines the method, there's a framework conflict or you've got double inclusions in your code.");
// attach the .equals method to Array's prototype to call it on any array
Array.prototype.equals = function (array) {
    // if the other array is a falsy value, return
    if (!array)
        return false;

    // compare lengths - can save a lot of time
    if (this.length != array.length)
        return false;

    for (var i = 0, l=this.length; i < l; i++) {
        // Check if we have nested arrays
        if (this[i] instanceof Array && array[i] instanceof Array) {
            // recurse into the nested arrays
            if (!this[i].equals(array[i]))
                return false;
        }
        else if (this[i] != array[i]) {
            // Warning - two different object instances will never be equal: {x:20} != {x:20}
            return false;
        }
    }
    return true;
}
// Hide method from for-in loops
Object.defineProperty(Array.prototype, "equals", {enumerable: false});
    class DebugInfo {
    constructor(sorterName) {
        this.sorterName = sorterName;
        this.reset();
    }
    reset() {
        this.startTime = null;
        this.totalTime = 0;
        this.numberOfDrawCalls = 0;
        this.numberOfTicks = 0;
        this.lastDrawCallStart = null;
        this.lastTickStart = null;
        this.avgDrawCallDuration = 0;
        this.avgTickDuration = 0;
        this.drawStartsList = [];
        this.operationsDone = [];
        this.operationsDoneTimings = [];
        this.lastRequestAnimationEnd = 0;
        this.numberOfRequestAnimations = 0;
        this.avgBrowserWorkTime = 0;
    }
    currentTotalTime() {
        if (this.startTime) {
            return this.totalTime + (new Date() - this.startTime);
        } else {
            return this.totalTime;
        }
    }
    start() {
        this.startTime = new Date();
    }
    stop() {
        if (this.startTime != null) {
            this.totalTime += (new Date() - this.startTime);
            this.startTime = null;
            this.drawStartsList = [];
            this.operationsDone = [];
            this.operationsDoneTimings = [];
            this.numberOfRequestAnimations = 0;
            this.lastRequestAnimationEnd = 0;                
        }
    }
    beginDraw() {
        this.lastDrawCallStart = new Date().getTime();
        this.drawStartsList.push(this.lastDrawCallStart);
        if (this.drawStartsList.length > 1200) this.drawStartsList.shift();
    }
    beginRequestAnimation() {
        if (this.lastRequestAnimationEnd == 0) return;
        let now = new Date().getTime();
        let callDuration = now - this.lastRequestAnimationEnd;
        this.avgBrowserWorkTime = (this.avgBrowserWorkTime * this.numberOfRequestAnimations + callDuration) / ++this.numberOfRequestAnimations;
    }
    endRequestAnimation() {
        this.lastRequestAnimationEnd = new Date().getTime();
    }
    endDraw() {
        let now = new Date().getTime();
        let callDuration = now - this.lastDrawCallStart;
        this.avgDrawCallDuration = (this.avgDrawCallDuration * this.numberOfDrawCalls + callDuration) / ++this.numberOfDrawCalls;
    }
    currentFps() {
        let now = new Date().getTime();
        let lastFrameInCurrentSecondI = 0;
        for (; lastFrameInCurrentSecondI < this.drawStartsList.length; lastFrameInCurrentSecondI++) {
            if (now - this.drawStartsList[lastFrameInCurrentSecondI] <= 1000) {
                break;
            }
        }
        this.drawStartsList.splice(0, lastFrameInCurrentSecondI);
        return this.drawStartsList.length;
    }
    currentOperationsDonePerSecond() {
        let now = new Date().getTime();
        let lastOperationsDoneInCurrentSecondI = 0;
        for (; lastOperationsDoneInCurrentSecondI < this.operationsDone.length; lastOperationsDoneInCurrentSecondI++) {
            if (now - this.operationsDoneTimings[lastOperationsDoneInCurrentSecondI] <= 1000) {
                break;
            }
        }
        this.operationsDone.splice(0, lastOperationsDoneInCurrentSecondI);
        this.operationsDoneTimings.splice(0, lastOperationsDoneInCurrentSecondI);
        let totalOperationsDoneInLastSecond = 0;
        for (let i = 0; i < this.operationsDone.length; i++) {
           totalOperationsDoneInLastSecond += this.operationsDone[i];
        }
        return totalOperationsDoneInLastSecond;
    }
    beginTick() {
        this.lastTickStart = new Date();
    }
    endTick() {
        let now = new Date();
        let tickDuration = now - this.lastTickStart;
        this.avgTickDuration = (this.avgTickDuration * this.numberOfTicks + tickDuration) / ++this.numberOfTicks;
    }

    addOperations(numberOfOperationsToAdd) {
        this.operationsDone.push(numberOfOperationsToAdd);
        this.operationsDoneTimings.push(new Date().getTime());
    }
                }
    </script>
    <!--<script type="text/javascript" src="sorters/BubbleSorter.js"></script>
    <script type="text/javascript" src="sorters/InsertionSorter.js"></script>
    <script type="text/javascript" src="sorters/MergeSorter.js"></script>
    <script type="text/javascript" src="sorters/HeapSorter.js"></script>
    <script type="text/javascript" src="sorters/QuickSorter.js"></script>
    <script type="text/javascript" src="sorters/Sorters.js"></script>
    <script type="text/javascript" src="utils-slash-hacks/ArrayUtils.js"></script>
    <script type="text/javascript" src="utils-slash-hacks/DebugUtils.js"></script>
    <script type="text/javascript" src="canvas/ColourUtils.js"></script>
    <!--<script type="text/javascript" src="sorters/SortersTest.js"></script>-->
    <title>🌈🤤Sorting algorithms</title>

    <style>
        /* to prevent ios from zooming-in */
        /*@media screen and (-webkit-min-device-pixel-ratio: 0)
          select:focus, textarea:focus, input:focus {
            font-size:16px;
          }
        }*/

        *.noselect {
          -webkit-touch-callout: none;
            -webkit-user-select: none;
             -khtml-user-select: none;
               -moz-user-select: none;
                -ms-user-select: none;
                    user-select: none;
        }

        canvas {
            /*image-rendering: optimizeSpeed;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: optimize-contrast;
            image-rendering: pixelated;
            -ms-interpolation-mode: nearest-neighbor;*/
            image-rendering: pixelated;   
        }
    </style>
</head>
<body>
<div id="mainBlock" class="noselect">

    <center><h1>Sorting Algorithms Visualisation</h1></center>
    <label>Source code: </label><a href="https://github.com/kisileno/colors">https://github.com/kisileno/colors</a>
    <br>
    <br>
    <input id="statusTextCheckbox" type="checkbox" checked/><label>Status text</label>
    <input id="debugInfoCheckbox" type="checkbox" checked/><label>Debug info</label>
    <input id="sizeInfoCheckbox" type="checkbox" checked/><label>Canvas size info</label>
    <br>
    <label>Canvas scale: </label><select id="canvasScaleSelect">
        <option value=0.015>1.5%, draw like it is 1980</option>
        <option value=0.025>2.5%, very pixelated</option>
        <option value=0.5>50%, pixelated</option>
        <option value=1>100%</option>
        <option value=1.5>150%</option>
        <option value=2>200%</option>
        <option value=3>300%, sharp</option>
        <option value=4>400%, sharpest</option>
    </select>
    <br>
    <label>Swaps per frame: </label><select id="swapsPerFrameSelect">
        <option value="50">50, fastest</option>
        <option value="25">25, faster</option>
        <option value="10">10, fast</option>
        <option value="1" selected="true">1 (smooth)</option>
        <option value="-5">each 5th, slow</option>
        <option value="-10">each 10th, slow</option>
        <option value="-30">each 50th, slideshow</option>
    </select>
    <br>
</div>
<script>

    const GLOBAL_COLOUR_MAP = [];
    let REFERENCE_COLOUR_ROW = null;

    const mainBlock = document.getElementById("mainBlock");
    const statusTextCheckbox = document.getElementById("statusTextCheckbox");
    const debugInfoCheckbox = document.getElementById("debugInfoCheckbox");
    const sizeInfoCheckbox = document.getElementById("sizeInfoCheckbox");
    const canvasScaleSelect = document.getElementById("canvasScaleSelect");
    const swapsPerFrameSelect = document.getElementById("swapsPerFrameSelect");

    const maxColourValue = 255;
    const realCanvasWidth = mainBlock.offsetWidth;
    let step = null;
    let CANVAS_SCALE = null;
    let swapsPerFrame = null;
    let statusTextEnabled = statusTextCheckbox.checked;
    let debugInfoEnabled = debugInfoCheckbox.checked;
    let sizeInfoEnabled = sizeInfoCheckbox.checked;

    allSorters.forEach(function (ss) {
        const sorterCheckbox = document.createElement('input');
        sorterCheckbox.type = "checkbox";
        sorterCheckbox.id = ss.name + "-CheckBox";
        sorterCheckbox.checked = ss.enabled;
        mainBlock.appendChild(sorterCheckbox);

        const sorterLabel = document.createElement('label');
        sorterLabel.innerHTML = ss.name + "    ";
        mainBlock.appendChild(sorterLabel);

        sorterCheckbox.onchange = function() {
           ss.enabled = sorterCheckbox.checked;
           createSorters(false);
        };
    });

    function calcStep() {
        step = 255 * 5 / ( realCanvasWidth * CANVAS_SCALE);
    }

    function addDefaultDisplayPixelRatio(scaleSelectElem) {
        const option = document.createElement('option');
        const defaultRatio = window.devicePixelRatio;
        option.value = defaultRatio;
        option.text = "Native scale: " + 100 * defaultRatio.toFixed(2) + "%";
        option.selected = true;
        scaleSelectElem.appendChild(option);
    }
    addDefaultDisplayPixelRatio(canvasScaleSelect);

    function onCanvasScaleSelectChange() {
        const newScale = parseFloat(canvasScaleSelect.options[canvasScaleSelect.selectedIndex].value);
        if (newScale != CANVAS_SCALE) {
            CANVAS_SCALE = newScale;
            calcStep();
            createSorters(true);
        }
    }
    canvasScaleSelect.onchange = onCanvasScaleSelectChange;
    onCanvasScaleSelectChange();

    function onSwapsPerFrameChange() {
        swapsPerFrame = parseFloat(swapsPerFrameSelect.options[swapsPerFrameSelect.selectedIndex].value);
    }
    swapsPerFrameSelect.onchange = onSwapsPerFrameChange;
    onSwapsPerFrameChange();

    statusTextCheckbox.onchange = function () {
        statusTextEnabled = statusTextCheckbox.checked;
        triggerRedraw();
    }
    sizeInfoCheckbox.onchange = function () {
        sizeInfoEnabled = sizeInfoCheckbox.checked;
        triggerRedraw();
    }
    debugInfoCheckbox.onchange = function () {
        debugInfoEnabled = debugInfoCheckbox.checked;
        triggerRedraw();
    }


    function REGISTER_ALL_THE_STUFF(sorterCanvas, constructorMethod, canvasWidth, canvasHeight, scaledWidth, scaledHeight, step) {
        if (REFERENCE_COLOUR_ROW == null) {
            REFERENCE_COLOUR_ROW = generateReferenceRow(scaledWidth, step);
            cacheColourObjects(REFERENCE_COLOUR_ROW, GLOBAL_COLOUR_MAP);
        }
        let matrix = populateColourMatrix(REFERENCE_COLOUR_ROW, scaledHeight);
        matrix.id = sorterCanvas.id + " matrix";
        let sorted = true;
        let statusText;
        const ctx = sorterCanvas.getContext("2d");
        ctx.imageSmoothingEnabled = false;
        const imageData = ctx.getImageData(0, 0, scaledWidth, scaledHeight);
        const actualData = imageData.data;
        const debugInfoObject = new DebugInfo("Not used yet.");

        function DRAW() {
            debugInfoObject.beginDraw();
            drawColourMatrix(matrix, ctx, imageData, actualData, scaledWidth);
            if (statusText && statusTextEnabled) drawStatusText(ctx, statusText, canvasWidth);
            if (debugInfoEnabled) drawDebugStats(ctx, debugInfoObject, canvasWidth, canvasHeight);
            if (sizeInfoEnabled) drawSizeText(ctx, canvasWidth, canvasHeight, scaledWidth, scaledHeight);
            debugInfoObject.endDraw();
        }

        function drawStatusText(ctx, textToDraw, canvasWidth) {
            ctx.fillStyle = "white";
            ctx.font = "bold 50px serif";
            let textMeasurements = ctx.measureText(textToDraw);
            ctx.fillText(statusText, canvasWidth - textMeasurements.width - 15, 50);
        }

        function drawSizeText(ctx, canvasWidth, canvasHeight, scaledWidth, scaledHeight) {
            ctx.font = "bold 20px serif";
            let text = scaledWidth + " × " + scaledHeight
            let textMeasurements = ctx.measureText(text);
            ctx.fillStyle = 'rgba(5, 5, 5, 0.5)';
            ctx.fillRect(10, 10, textMeasurements.width + 10, 25);
            ctx.fillStyle = "white";
            ctx.fillText(text, 15, 30);
        }

        function drawDebugStats(ctx, debugInfo, canvasWidth, canvasHeight) {
            let debugRectangleWidth = 200;
            let debugRectangleHeight = 135;
            let x = canvasWidth - debugRectangleWidth;
            let y = canvasHeight - debugRectangleHeight;
            ctx.fillStyle = 'rgba(5, 5, 5, 0.5)';
            ctx.fillRect(x, y, debugRectangleWidth, debugRectangleHeight);

            ctx.fillStyle = "white";
            ctx.font = "bold 15px serif";

            let timeSpent = debugInfo.currentTotalTime();
            let millisecondsInMinute = 1000 * 60;
            let timeSpentFormatted = "Time spent: "
                + Math.floor(timeSpent / (millisecondsInMinute)) + " min "
                + Number((timeSpent % (millisecondsInMinute)) / 1000).toFixed(1) + " sec ";
            ctx.fillText(timeSpentFormatted, x + 10, y + 20, debugRectangleWidth);

            let totalDrawCalls = "Total draw calls: " + debugInfo.numberOfDrawCalls;
            ctx.fillText(totalDrawCalls, x + 10, y + 35, debugRectangleWidth);

            let currentFps = "Current FPS: " + debugInfo.currentFps();
            ctx.fillText(currentFps, x + 10, y + 50, debugRectangleWidth);

            let avgDrawCallDuration = "Avg Draw time: " + Number(debugInfo.avgDrawCallDuration).toFixed(2) + " ms";
            ctx.fillText(avgDrawCallDuration, x + 10, y + 65, debugRectangleWidth);

            let monitorRefreshRate = 60; //TODO calc monitor refresh rate properly
            let actualBrowserWork = Math.max(0, debugInfo.avgBrowserWorkTime - (1000/monitorRefreshRate - debugInfo.avgTickDuration - debugInfo.avgDrawCallDuration));
            let avgBrowserWork = "Avg Browser lag: " + Number(actualBrowserWork).toFixed(2) + " ms";
            ctx.fillText(avgBrowserWork, x + 10, y + 80, debugRectangleWidth);

            let avgTickDuration = "Avg Sort time: " + Number(debugInfo.avgTickDuration).toFixed(2) + " ms";
            ctx.fillText(avgTickDuration, x + 10, y + 95, debugRectangleWidth);

            let avgFps = "Avg FPS: " + Number(debugInfo.numberOfDrawCalls * 1000 / timeSpent).toFixed(2);
            ctx.fillText(avgFps, x + 10, y + 110, debugRectangleWidth);

            let currentOpPerSec = "Swaps per sec: " + debugInfo.currentOperationsDonePerSecond();
            ctx.fillText(currentOpPerSec, x + 10, y + 125, debugRectangleWidth);
        }

        let sorters = [];
        for (let i = 0; i < matrix.length; i++) {
            sorters.push(constructorMethod(new CanvasArrayWrapper(actualData, 4 * i * scaledWidth, 4 * i * scaledWidth + scaledWidth * 4 - 4), DEFAULT_COLOUR_COMP));
        }

        let sortStarted = false;
        let dryRunsToDo = 0;
        let chainedTick = function () {
            debugInfoObject.beginRequestAnimation();
            if (!sortStarted) {
                DRAW();
                return;
            }
            debugInfoObject.beginTick();

            let somethingChanged = true; //legacy, delete, damn, now it is used for dry runs :/
            let numberOfSwapsHappened = 0;
            if (swapsPerFrame < 0 && dryRunsToDo == 0) {  //slow mode enabled
                dryRunsToDo = -swapsPerFrame;
            } else if (swapsPerFrame < 0 && dryRunsToDo != 1) {
                dryRunsToDo--;
            } else {
                somethingChanged = false;
                let swapsToDo = swapsPerFrame < 0 ? 1 : swapsPerFrame;
                for (let run = 0; run < swapsToDo; run++ ) {
                    for (let i = 0; i < sorters.length; i++) {
                        let particularTickChange = sorters[i].oneTick();
                        if (particularTickChange) {
                            somethingChanged = true;
                            numberOfSwapsHappened++;
                        }
                    }
                 }
                 dryRunsToDo = 0;
            }
            debugInfoObject.endTick();
            debugInfoObject.addOperations(numberOfSwapsHappened);
            if (!somethingChanged) {
                statusText = "All Sorted";
                sorted = true;
                sortStarted = false;
                DRAW();
            } else {
                DRAW();
                window.requestAnimationFrame(chainedTick);
            }
            debugInfoObject.endRequestAnimation();
        };

        function shuffleTheStuff() {
            for (let i = 0; i < matrix.length; i++) {
                shuffle(matrix[i]);
                sorters[i].reset();
            }
            sorted = false;
            statusText = "Shuffled"
        }

        shuffleTheStuff();
        statusText = "Click me";
        putMatrixToCanvasData(matrix, actualData, scaledWidth);
        DRAW();
        let regularClick = function () {
            if (sorted) {
                shuffleTheStuff();
                debugInfoObject.reset();
                putMatrixToCanvasData(matrix, actualData, scaledWidth);
                DRAW();
            } else if (sortStarted) {
                statusText = "Paused";
                debugInfoObject.stop();
                sortStarted = false;
            } else {
                statusText = "Sorting";
                sortStarted = true;
                debugInfoObject.start();
                chainedTick();
            }
        };
        sorterCanvas.onclick = regularClick;
        const visibilityChangeHandler = function() {
            if (document.visibilityState == 'hidden') {
                debugInfoObject.stop();
            } else {
                debugInfoObject.start();
            }
        }
        document.addEventListener('visibilitychange', visibilityChangeHandler, false);
        sorterCanvas.destroy = function() {
            sortStarted = false;
            statusText = "Destroyed";
            document.removeEventListener('visibilitychange', visibilityChangeHandler, false);
        }
        sorterCanvas._draw = function () {
            if (!sortStarted) {
                DRAW();
            }
        }
    }

    function createSorters(forceRecreate) {
        if (forceRecreate) {
            GLOBAL_COLOUR_MAP.length = 0;
            REFERENCE_COLOUR_ROW = null;
        }
        allSorters.forEach(function (ss) {

            const sorterDivId = ss.name + "-id";
            let oldSorterDiv = document.getElementById(sorterDivId);
            if ((oldSorterDiv && !ss.enabled) || (oldSorterDiv && forceRecreate)) {
                getCanvasFromSorterDiv(oldSorterDiv).destroy();
                mainBlock.removeChild(oldSorterDiv);
            }
            if (!ss.enabled) return;
            if (!forceRecreate && oldSorterDiv) return;

            let sorterDiv = document.createElement('div');
            sorterDiv.id = sorterDivId;
            let sorterName = document.createElement('h3');
            sorterName.innerHTML = ss.name;
            let sorterDescription = document.createElement('label');
            sorterDescription.innerHTML = ss.description;
            let br = document.createElement('br');

            const canvasHeight = Math.ceil(realCanvasWidth / 2.2);
            let sorterCanvas = document.createElement('canvas');
            sorterCanvas.id = ss.name + "CanvasId";
            sorterCanvas.width = realCanvasWidth;
            sorterCanvas.height = canvasHeight;
            sorterCanvas.innerHTML = "There should be HTML canvas with a pretty animation, but looks like something broke.";

            const originalCanvasWidth = sorterCanvas.width;
            const originalCanvasHeight = sorterCanvas.height;
            const scaledCanvasWidth = Math.floor(originalCanvasWidth * CANVAS_SCALE);
            const scaledCanvasHeight = Math.floor(originalCanvasHeight * CANVAS_SCALE);
    
            sorterCanvas.width = scaledCanvasWidth;
            sorterCanvas.height = scaledCanvasHeight;
            sorterCanvas.setAttribute("style", "width:" + (scaledCanvasWidth / CANVAS_SCALE) + "px");
            sorterCanvas.setAttribute("style", "height:" + (scaledCanvasHeight / CANVAS_SCALE) + "px");

            let ctx = sorterCanvas.getContext("2d");
            ctx.scale(CANVAS_SCALE, CANVAS_SCALE);
            
            sorterDiv.appendChild(sorterName);
            sorterDiv.appendChild(sorterDescription);
            sorterDiv.appendChild(br);
            sorterDiv.appendChild(sorterCanvas);
            mainBlock.appendChild(sorterDiv);

            REGISTER_ALL_THE_STUFF(sorterCanvas, ss.constructorMethod, originalCanvasWidth, originalCanvasHeight, scaledCanvasWidth, scaledCanvasHeight, step);
        });
    }

    function getCanvasFromSorterDiv(sorterDiv) {
        for (let childElem of sorterDiv.children) {
            if (childElem.id.indexOf("CanvasId") > -1) {
                return childElem;
             }
        }
        return null;
    }

    function triggerRedraw() {
         allSorters.forEach(function (ss) {
             const sorterDivId = ss.name + "-id";
             let oldSorterDiv = document.getElementById(sorterDivId);
             if (oldSorterDiv) {
                getCanvasFromSorterDiv(oldSorterDiv)._draw();
             }
         });
    }
</script>
</body>
</html>
