<!DOCTYPE html>
<html>
<head>
    <script type="text/javascript" src="Colour.js"></script>
    <script type="text/javascript" src="sorters/BubbleSorter.js"></script>
    <script type="text/javascript" src="sorters/InsertionSorter.js"></script>
    <script type="text/javascript" src="sorters/MergeSorter.js"></script>
    <script type="text/javascript" src="sorters/HeapSorter.js"></script>
    <script type="text/javascript" src="sorters/QuickSorter.js"></script>
    <script type="text/javascript" src="sorters/Sorters.js"></script>
    <script type="text/javascript" src="utils-slash-hacks/ArrayUtils.js"></script>
    <script type="text/javascript" src="utils-slash-hacks/DebugUtils.js"></script>
    <script type="text/javascript" src="canvas/ColourUtils.js"></script>
    <!--<script type="text/javascript" src="sorters/SortersTest.js"></script>-->
    <title>ðŸŒˆSorting algorithmsðŸ¤¤</title>
</head>
<body>
<div id="mainBlock">

    <h1>Sorting algorithms swap comparisons</h1>
    <input id="statusTextCheckbox" type="checkbox" checked/><label>Status text</label>
    <input id="debugInfoCheckbox" type="checkbox" checked/><label>Debug info</label>
    <input id="sizeInfoCheckbox" type="checkbox" checked/><label>Canvas Size info</label>

</div>
<script>

    const GLOBAL_COLOUR_MAP = [];
    let globalMapBuilt = false;

    const mainBlock = document.getElementById("mainBlock");
    const statusTextCheckbox = document.getElementById("statusTextCheckbox");
    const debugInfoCheckbox = document.getElementById("debugInfoCheckbox");
    const sizeInfoCheckbox = document.getElementById("sizeInfoCheckbox");

    const maxColourValue = 255;
    const canvasWidth_GIVNO = mainBlock.offsetWidth;
    const step = maxColourValue * 5 / canvasWidth_GIVNO;

    function REGISTER_ALL_THE_SHIT(sorterCanvas, constructorMethod, canvasWidth, canvasHeight, scaledWidth, scaledHeight, step) {
        let matrix = generateColourMatrix(scaledWidth, scaledHeight, step);
        if (!globalMapBuilt) {
            cacheColourObjects(matrix[0], GLOBAL_COLOUR_MAP);
            globalMapBuilt = true;
        }
        matrix.id = sorterCanvas.id + " matrix";
        let sorted = true;
        let statusText;
        const ctx = sorterCanvas.getContext("2d");
        const imageData = ctx.getImageData(0, 0, scaledWidth, scaledHeight);
        const actualData = imageData.data;
        const debugInfoObject = new DebugInfo("Not used yet.");

        function DRAW() {
            debugInfoObject.beginDraw();
            drawColourMatrix(matrix, ctx, imageData, actualData, scaledWidth);
            debugInfoObject.endDraw();
            if (statusText && statusTextCheckbox.checked) drawStatusText(ctx, statusText, canvasWidth);
            if (debugInfoCheckbox.checked) drawDebugStats(ctx, debugInfoObject, canvasWidth, canvasHeight);
            if (sizeInfoCheckbox.checked) drawSizeText(ctx, canvasWidth, canvasHeight, scaledWidth, scaledHeight);
        }

        function drawStatusText(ctx, textToDraw, canvasWidth) {
            ctx.fillStyle = "white";
            ctx.font = "bold 50px serif ";
            let textMeasurements = ctx.measureText(textToDraw);
            ctx.fillText(statusText, canvasWidth - textMeasurements.width - 15, 50);
        }

        function drawSizeText(ctx, canvasWidth, canvasHeight, scaledWidth, scaledHeight) {
            ctx.font = "bold 20px serif ";
            let text = scaledWidth + " Ã— " + scaledHeight
            let textMeasurements = ctx.measureText(text);
            ctx.fillStyle = 'rgba(5, 5, 5, 0.5)';
            ctx.fillRect(10, 10, textMeasurements.width + 10, 25);
            ctx.fillStyle = "white";
            ctx.fillText(text, 15, 30);
        }

        function drawDebugStats(ctx, debugInfo, canvasWidth, canvasHeight) {
            let debugRectangleWidth = 200;
            let debugRectangleHeight = 135;
            let x = canvasWidth - debugRectangleWidth;
            let y = canvasHeight - debugRectangleHeight;
            ctx.fillStyle = 'rgba(5, 5, 5, 0.5)';
            ctx.fillRect(x, y, debugRectangleWidth, debugRectangleHeight);

            ctx.fillStyle = "white";
            ctx.font = "bold 15px serif ";

            let timeSpent = debugInfo.currentTotalTime();
            let millisecondsInMinute = 1000 * 60;
            let timeSpentFormatted = "Time spent: "
                + Math.floor(timeSpent / (millisecondsInMinute)) + " min "
                + Number((timeSpent % (millisecondsInMinute)) / 1000).toFixed(1) + " sec ";
            ctx.fillText(timeSpentFormatted, x + 10, y + 20, debugRectangleWidth);

            let totalDrawCalls = "Total draw calls: " + debugInfo.numberOfDrawCalls;
            ctx.fillText(totalDrawCalls, x + 10, y + 35, debugRectangleWidth);

            let currentFps = "Current FPS: " + debugInfo.currentFps();
            ctx.fillText(currentFps, x + 10, y + 50, debugRectangleWidth);

            let avgDrawCallDuration = "Avg Draw time: " + Number(debugInfo.avgDrawCallDuration).toFixed(2) + " ms";
            ctx.fillText(avgDrawCallDuration, x + 10, y + 65, debugRectangleWidth);

            let monitorRefreshRate = 60;
            let actualBrowserWork = Math.max(0, debugInfo.avgBrowserWorkTime - 1000/60);
            let avgBrowserWork = "Avg Browser lag: " + Number(actualBrowserWork).toFixed(2) + " ms";
            ctx.fillText(avgBrowserWork, x + 10, y + 80, debugRectangleWidth);

            let avgTickDuration = "Avg Sort time: " + Number(debugInfo.avgTickDuration).toFixed(2) + " ms";
            ctx.fillText(avgTickDuration, x + 10, y + 95, debugRectangleWidth);

            let avgFps = "Avg FPS: " + Number(debugInfo.numberOfDrawCalls * 1000 / timeSpent).toFixed(2);
            ctx.fillText(avgFps, x + 10, y + 110, debugRectangleWidth);

            let currentOpPerSec = "Swaps per sec: " + debugInfo.currentOperationsDonePerSecond();
            ctx.fillText(currentOpPerSec, x + 10, y + 125, debugRectangleWidth);
        }

        let sorters = [];
        for (let i = 0; i < matrix.length; i++) {
            sorters.push(constructorMethod(new CanvasArrayWrapper(actualData, 4 * i * scaledWidth, 4 * i * scaledWidth + scaledWidth * 4 - 4), DEFAULT_COLOUR_COMP));
        }

        let sortStarted = false;
        let chainedTick = function () {
            debugInfoObject.beginRequestAnimation();
            if (!sortStarted) {
                DRAW();
                return;
            }
            let somethingChanged = false; //legacy, delete
            debugInfoObject.beginTick();
            let numberOfSwapsHappened = 0;
            for (let i = 0; i < sorters.length; i++) {
                let particularTickChange = sorters[i].oneTick();
                if (particularTickChange) {
                    somethingChanged = true;
                    numberOfSwapsHappened++;
                }
            }
            debugInfoObject.endTick();
            debugInfoObject.addOperations(numberOfSwapsHappened);
            if (!somethingChanged) {
                statusText = "All Sorted";
                sorted = true;
                sortStarted = false;
                DRAW();
            } else {
                DRAW();
                window.requestAnimationFrame(chainedTick);
            }
            debugInfoObject.endRequestAnimation();
        };

        function shuffleTheStuff() {
            for (let i = 0; i < matrix.length; i++) {
                shuffle(matrix[i]);
                sorters[i].reset();
            }
            sorted = false;
            statusText = "Shuffled"
        }

        shuffleTheStuff();
        statusText = "Click me";
        putMatrixToCanvasData(matrix, actualData, scaledWidth);
        DRAW();
        let regularClick = function () {
            if (sorted) {
                shuffleTheStuff();
                debugInfoObject.reset();
                putMatrixToCanvasData(matrix, actualData, scaledWidth);
                DRAW();
            } else if (sortStarted) {
                statusText = "Paused";
                debugInfoObject.stop();
                sortStarted = false;
            } else {
                statusText = "Sorting";
                sortStarted = true;
                debugInfoObject.start();
                chainedTick();
            }
        };
        sorterCanvas.onclick = regularClick;
    }

    allSorters.forEach(function (ss) {
        if (!ss.enabled) return;

        let sorterDiv = document.createElement('div');

        sorterDiv.id = ss.name + "-" + ss.name;
        let sorterName = document.createElement('h3');
        sorterName.innerHTML = ss.name;
        let sorterDescription = document.createElement('label');
        sorterDescription.innerHTML = ss.description;
        let br = document.createElement('br');

        const canvasHeight = Math.ceil(canvasWidth_GIVNO / 2.2);
        let sorterCanvas = document.createElement('canvas');
        sorterCanvas.id = ss.name + "CanvasId";
        sorterCanvas.width = canvasWidth_GIVNO;
        sorterCanvas.height = canvasHeight;
        sorterCanvas.innerHTML = "There should be HTML canvas with a pretty animation, but looks like something broke.";

        const originalCanvasWidth = sorterCanvas.width;
        const originalCanvasHeight = sorterCanvas.height;
        const scaledCanvasWidth = Math.floor(originalCanvasWidth * window.devicePixelRatio);
        const scaledCanvasHeight = Math.floor(originalCanvasHeight * window.devicePixelRatio);

        let ctx = sorterCanvas.getContext("2d");
        if (window.devicePixelRatio > 1) {
            sorterCanvas.width = scaledCanvasWidth;
            sorterCanvas.height = scaledCanvasHeight;
            sorterCanvas.setAttribute("style", "width:" + originalCanvasWidth + "px");
            sorterCanvas.setAttribute("style", "height:" + originalCanvasHeight + "px");
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }

        sorterDiv.appendChild(sorterName);
        sorterDiv.appendChild(sorterDescription);
        sorterDiv.appendChild(br);
        sorterDiv.appendChild(sorterCanvas);
        mainBlock.appendChild(sorterDiv);

        REGISTER_ALL_THE_SHIT(sorterCanvas, ss.constructorMethod, originalCanvasWidth, originalCanvasHeight, scaledCanvasWidth, scaledCanvasHeight, step);
    });


</script>

</body>
</html>
