<!DOCTYPE html>
<html>
<body>
<div id="mainBlock">

    <h1>Sorting algorithms swap comparisons</h1>

</div>
<script>
    let timeSpentOnActualCanvasDraw = 0;
    let timeSpentOnCanvasDataManipulation = 0;

    class SorterSummary {

        constructor(name, constructorMethod, description) {
            this.name = name;
            this.constructorMethod = constructorMethod;
            this.description = description;
        }
    }


    class BubbleSorter {
        constructor(arrayToSort, comparator) {
            this.arr = arrayToSort;
            this.comparator = comparator;
            this.reset();
        }

        reset() {
            this.patientInd = 0;
        }

        oneTick() {
            for (let i = this.patientInd + 1; i < this.arr.length - 1; i++) {
                let patient = this.arr[this.patientInd];
                let toComp = this.arr[i + 1];
                if (this.comparator(patient, toComp) > 0) {
                    this.arr[this.patientInd] = toComp;
                    this.arr[i + 1] = patient;
                    return true;
                }
            }
            this.patientInd += 1;
            return this.patientInd === this.arr.length - 1;
        }
    }

    class InsertionSorter {
        constructor(arrayToSort, comparator) {
            this.arr = arrayToSort;
            this.comparator = comparator;
        }

        reset() {
            this.patientInd = -1;
        }

        oneTick() {
            for (let i = this.patientInd + 1; i < this.arr.length - 1; i++) {
                let patient = this.arr[i];
                let toComp = this.arr[i + 1];
                if (this.comparator(patient, toComp) > 0) {
                    this.arr[i] = toComp;
                    this.arr[i + 1] = patient;
                    return true;
                }
            }
            this.patientInd += 1;
            return this.patientInd === this.arr.length - 1;
        }
    }


    class Slice {
        constructor(low, high) {
            this.low = low;
            this.high = high;
            this.i = null;
            this.j = null;
            this.midElem = null;
        }
    }

    class QuickSorter {

        constructor(arrayToSort, comparator) {
            this.arr = arrayToSort;
            this.comparator = comparator;
            this.reset();
        }

        reset() {
            this.slicesToSort = [new Slice(0, this.arr.length - 1)];
        }

        oneTick() {
            while (this.slicesToSort.length > 0) {
                let slice = this.slicesToSort.pop();
                if (slice.low < slice.high) {
                    let midElem = slice.midElem || this.arr[Math.floor(slice.low + (slice.high - slice.low) / 2)];
                    slice.midElem = midElem;
                    let i = slice.i || slice.low;
                    let j = slice.j || slice.high;
                    while (i <= j) {
                        while (this.comparator(this.arr[i], midElem) < 0) {
                            i++;
                        }
                        while (this.comparator(this.arr[j], midElem) > 0) {
                            j--;
                        }
                        if (i <= j) {
                            let tmp = this.arr[i];
                            this.arr[i] = this.arr[j];
                            this.arr[j] = tmp;
                            slice.i = i + 1;
                            slice.j = j - 1;
                            this.slicesToSort.push(slice);
                            return true;
                        }
                    }
                    if (slice.low < j) {
                        this.slicesToSort.push(new Slice(slice.low, j));
                    }
                    if (slice.high > i) {
                        this.slicesToSort.push(new Slice(i, slice.high));
                    }
                    //shuffle(this.slicesToSort)
                }
            }
            return false;
        }
    }

    class PartForMerge {
        constructor(arr, i, j) {
            this.arr = arr;
            this.i = i;
            this.j = j;
            this.localPointer = 0;
        }
    }

    class MergeSorter {
        constructor(arrayToSort, comparator) {
            this.arr = arrayToSort;
            this.comparator = comparator;
            this.reset();
        }

        reset() {
            this.partsToMerge = [];
            this.mergeInProgress = false;
            this.arrPointer = null;
            for (let i = 0; i < this.arr.length; i++) {
                this.partsToMerge.push(new PartForMerge([this.arr[i]], i, i));
            }
        }


        oneTick() {
            while (this.partsToMerge.length > 1) {
                let part1 = this.partsToMerge.pop();
                let part2 = this.partsToMerge.pop();
                if (!this.mergeInProgress) {
                    this.arrPointer = Math.min(part1.i, part2.i);
                    this.mergeInProgress = true;
                }
                let patient1 = part1.arr[part1.localPointer];
                let patient2 = part2.arr[part2.localPointer];

                if (!patient1 && !patient2) {
                    this.mergeInProgress = false;
                    let low = Math.min(part1.i, part2.i);
                    let high = low + part1.arr.length + part2.arr.length;
                    this.partsToMerge.unshift(new PartForMerge(this.arr.slice(low, high), low, high));
                } else if (!patient1 && patient2) {
                    this.arr[this.arrPointer++] = patient2;
                    part2.localPointer++;
                    this.partsToMerge.push(part2);
                    this.partsToMerge.push(part1);
                    return true;
                } else if (!patient2 && patient1) {
                    this.arr[this.arrPointer++] = patient1;
                    part1.localPointer++;
                    this.partsToMerge.push(part2);
                    this.partsToMerge.push(part1);
                    return true;
                } else if (this.comparator(patient1, patient2) < 0) {
                    this.arr[this.arrPointer++] = patient1;
                    part1.localPointer++;
                    this.partsToMerge.push(part2);
                    this.partsToMerge.push(part1);
                    return true;
                } else {
                    this.arr[this.arrPointer++] = patient2;
                    part2.localPointer++;
                    this.partsToMerge.push(part2);
                    this.partsToMerge.push(part1);
                    return true;
                }
            }
            this.partsToMerge.pop();
            return false;
        }
    }

    class HeapSorter {

        constructor(arrayToSort, comparator) {
            this.arr = arrayToSort;
            this.comparator = comparator;
            this.reset();
        }

        reset() {
            this.heapPreparationDone = false;
            this.heapSortingSwapJustDone = false;
            this.heapSize = this.arr.length;
            this.heapSortingI = this.arr.length - 1;
            this.heapPreparationI = Math.floor(this.arr.length / 2);
            this.heapNextMax = this.heapPreparationI;
        }

        oneTick() {
            if (!this.heapPreparationDone) {
                if (this.heapPreparationI <= 0 && this.heapNextMax === null) {
                    this.heapPreparationDone = true;
                } else {
                    if (this.heapNextMax === null) {
                        this.heapNextMax = --this.heapPreparationI
                    }
                    this.heapNextMax = this.sortHeapFrom(this.arr, this.heapNextMax, this.heapSize);
                    return true;
                }
            }
            if (this.heapSortingI > 0) {
                if (this.heapSortingSwapJustDone) {
                    if (this.heapNextMax === null) {
                        this.heapNextMax = 0;
                        --this.heapSize;
                    }
                    this.heapNextMax = this.sortHeapFrom(this.arr, this.heapNextMax, this.heapSize);
                    if (this.heapNextMax !== null) {
                        return true;
                    }
                    this.heapSortingI--;
                    this.heapSortingSwapJustDone = false;
                    return true;
                } else {
                    HeapSorter.swap(this.arr, 0, this.heapSortingI);
                    this.heapSortingSwapJustDone = true;
                    return true;
                }
            }
            return false;
        }

        sortHeapFrom(arr, nextMax, heapLength) {
            let left = 2 * nextMax + 1;
            let right = 2 * nextMax + 2;
            let max = nextMax;
            if (left < heapLength && this.comparator(arr[left], arr[max]) > 0) {
                max = left;
            }
            if (right < heapLength && this.comparator(arr[right], arr[max]) > 0) {
                max = right;
            }
            if (max !== nextMax) {
                HeapSorter.swap(arr, nextMax, max);
                return max;
            }
            return null;
        }

        static swap(arr, i, j) {
            let tmp = arr[i];
            arr[i] = arr[j];
            arr[j] = tmp;
        }
    }

    /*
        var arr = [1,2,3,4,5];
        shuffle(arr);
        var s = new HeapSorter(arr, function(n1, n2) {return n1-n2;});

    */
    function shuffle(a) {
        for (let i = a.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [a[i], a[j]] = [a[j], a[i]];
        }
    }


    const allSorters = [
        new SorterSummary(
            "Bubble Sort",
            function (array, comparator) {
                return new BubbleSorter(array, comparator);
            },
            "This is a basic bubble sort impl."),
        new SorterSummary(
            "Insertion Sort",
            function (array, comparator) {
                return new InsertionSorter(array, comparator);
            },
            "This is a basic insertion sort impl."),
        new SorterSummary(
            "Merge Sort",
            function (array, comparator) {
                return new MergeSorter(array, comparator);
            },
            "This is an iterative version of a merge sort which commits every merge result back to the source array."),
        new SorterSummary(
            "Quick Sort",
            function (array, comparator) {
                return new QuickSorter(array, comparator);
            },
            "This is a basic implementation of the quick sort"),
        new SorterSummary(
            "Heap Sort",
            function (array, comparator) {
                return new HeapSorter(array, comparator);
            },
            "This is a heap sort implementation.")
    ];


    const mainBlock = document.getElementById("mainBlock");

    const maxColourValue = 255;
    const maxCanvasWidth = maxColourValue * 5;
    const documentWidth = document.documentElement.clientWidth;
    const step = Math.max(1, Math.ceil(maxCanvasWidth / documentWidth));
    const canvasWidth = Math.round(maxCanvasWidth / step);
    const DEFAULT_COLOUR_COMP = function (c1, c2) {
        return c1.compare(c2);
    };

    class Colour {

        constructor(red, green, blue) {
            this.red = Colour.to255Range(red);
            this.green = Colour.to255Range(green);
            this.blue = Colour.to255Range(blue);
            this.hue = Colour.getWikiHue(this);
        }

        static to255Range(n) {
            return Math.max(Math.min(n, 255), 0);
        }

        static randomColour() {
            function pizde() {
                return Math.ceil(Math.random() * 255);
            }

            return new Colour(pizde(), pizde(), pizde());
        }


        static getWikiHue(colour) {
            const R = colour.red;
            const G = colour.green;
            const B = colour.blue;

            if (R >= G && G >= B) {
                //return 60 * (G - B) / (R - B);
                return 60 * G / R;
            }
            if (G > R && R >= B) {
                return 60 * (2 - (R - B) / (G - B));
            }
            if (G >= B && B > R) {
                return 60 * (2 + (B - R) / (G - R));
            }
            if (B > G && G > R) {
                return 60 * (4 - (G - R) / (B - R));
            }
            if (B > R && R >= G) {
                return 60 * (4 + (R - G) / (B - G));
            }
            if (R >= B && B > G) {
                return 60 * (6 - (B - G) / (R - G));
            }
        }

        equals(other) {
            return this.red === other.red && this.green === other.green && this.blue === other.blue;

        }

        compare(other) {
            return this.hue - other.hue;
        }
    }


    function REGISTER_ALL_THE_SHIT(sorterCanvas, constructorMethod, canvasWidth, canvasHeight, step) {
        let matrix = generateColourMatrix(canvasWidth, canvasHeight, step);
        matrix.id = sorterCanvas.id + " matrix";
        let sorted = true;
        let statusText;
        const ctx = sorterCanvas.getContext("2d");
        const imageData = ctx.getImageData(0, 0, sorterCanvas.width, canvasHeight);
        const actualData = imageData.data;
        const targetFps = 60;
        const redrawEvery = 1;

        let numberOfTicks = 0;
        let totalTimeSpent = 0;
        let timeSpentOnDraw = 0;
        let drawCalls = 0;

        function DRAW() {
            drawCalls++;
            let beforeDraw = new Date();
            drawColourMatrix(matrix, ctx, imageData, actualData, canvasWidth);
            if (statusText) drawStatusText(ctx, statusText, canvasWidth);
            let afterDraw = new Date();
            timeSpentOnDraw += (afterDraw - beforeDraw);
        }

        function drawStatusText(ctx, textToDraw, canvasWidth) {


            ctx.fillStyle = "white"
            ctx.font = "bold 50px serif ";
            let textMeasurements = ctx.measureText(textToDraw);
            ctx.fillText(statusText, canvasWidth - textMeasurements.width - 15, 50);

        }


        let sorters = [];
        for (let i = 0; i < matrix.length; i++) {
            sorters.push(constructorMethod(matrix[i], DEFAULT_COLOUR_COMP));
        }

        let sortStarted = false;
        let justACounter = 0;
        let chainedTick = function () {
            if (!sortStarted) {
                console.log("SORT SUSPENDED", sorterCanvas.id);
                statusText = "Paused";
                stopReDraw();
                console.log("number of ticks:", numberOfTicks);
                console.log("total time: ", totalTimeSpent, totalTimeSpent/numberOfTicks);
                console.log(" time spent on draw", timeSpentOnDraw, timeSpentOnDraw/drawCalls);
                console.log(" time spent on CANVAS", timeSpentOnActualCanvasDraw, timeSpentOnActualCanvasDraw/drawCalls);
                console.log(" time spent on data manipulation", timeSpentOnCanvasDataManipulation, timeSpentOnCanvasDataManipulation/drawCalls);
                return;
            }
            let somethingChanged = false;
            let beforeTick = new Date();
            for (let i = 0; i < sorters.length; i++) {
                somethingChanged = sorters[i].oneTick() || somethingChanged;
            }
            let afterTick = new Date();
            totalTimeSpent += (afterTick - beforeTick);
            numberOfTicks++;
            if (!somethingChanged) {
                console.log("Sorted");
                statusText= "All Sorted. DrawCalls " + drawCalls ;
                //1627
                console.log("number of ticks:", numberOfTicks);
                console.log("total time: ", totalTimeSpent, totalTimeSpent/numberOfTicks);
                console.log(" time spent on draw", timeSpentOnDraw, timeSpentOnDraw/drawCalls);
                console.log(" time spent on CANVAS", timeSpentOnActualCanvasDraw, timeSpentOnActualCanvasDraw/drawCalls);
                sorted = true;
                sortStarted = false;
                stopReDraw();
            } else {
                justACounter++;
                if (justACounter % redrawEvery == 0) {
                    hasSomethingToDraw = true;
                    //setTimeout(chainedTick, 1500 / targetFps);
                    DRAW();
                } else {
                    //chainedTick();
                }
                window.requestAnimationFrame(chainedTick);

            }
        };
        let reDrawInterval;
        let hasSomethingToDraw = true;

        function stopReDraw() {
            DRAW();
            clearInterval(reDrawInterval);
        }

        function registerReDraw() {
            stopReDraw();
            let fps = targetFps;
            if (fps === 0) {
                return;
            }
            let delay = 1000 / fps;
            //console.log("REGISTERING REDRAW: ", fps, delay);
            reDrawInterval = setInterval(function () {
                if (hasSomethingToDraw) {
                    DRAW();
                    hasSomethingToDraw = false;
                }
            }, delay);

        }

        function registerRequestFrameChainedRedraw() {
            if (hasSomethingToDraw) {
                DRAW();
                hasSomethingToDraw = false;
            }
            window.requestAnimationFrame(registerRequestFrameChainedRedraw);
        }

        function shuffleTheStuff() {
            for (let i = 0; i < matrix.length; i++) {
                    shuffle(matrix[i]);
                    sorters[i].reset();
                }
            sorted = false;
            statusText = "Shuffled"
        }
        shuffleTheStuff();
        statusText = "Click me";
        DRAW();
        sorterCanvas.onclick = function () {
            if (sorted) {
                shuffleTheStuff();
                DRAW();
            } else if (sortStarted) {
                console.log("tipa stopping sort");
                sortStarted = false;
            } else {
                console.log("starting sort");
                statusText = "Sorting";
                sortStarted = true;
                chainedTick();
                //registerReDraw();
                //registerRequestFrameChainedRedraw();
            }
        };
    };

    allSorters.forEach(function (ss) {

        let sorterDiv = document.createElement('div');

        sorterDiv.id = ss.name + "-" + ss.name;
        let sorterName = document.createElement('h3');
        sorterName.innerHTML = ss.name;
        //sorterName.setAttribute('style', "align:left");
        let sorterDescription = document.createElement('label');
        sorterDescription.innerHTML = ss.description;
        let br = document.createElement('br');

        //const canvasWidth = canvasWidth;
        const canvasHeight = canvasWidth / 2;
        let sorterCanvas = document.createElement('canvas');
        sorterCanvas.id = ss.name + "CanvasId";
        sorterCanvas.width = canvasWidth;
        sorterCanvas.height = canvasHeight;
        sorterCanvas.innerHTML = "There should be HTML canvas with pretty animation, but fuck you."

        sorterDiv.appendChild(sorterName);
        sorterDiv.appendChild(sorterDescription);
        sorterDiv.appendChild(br);
        sorterDiv.appendChild(sorterCanvas);
        mainBlock.appendChild(sorterDiv);


        REGISTER_ALL_THE_SHIT(sorterCanvas, ss.constructorMethod, canvasWidth, canvasHeight, step);


    });

   

    function applyStep(vals, steps, wasOnLims, pos, step, maxTimes) {
        vals[pos] += steps[pos];
        if (vals[pos] >= maxColourValue) {
            if (wasOnLims[pos] < maxTimes) {
                wasOnLims[pos]++;
                steps[pos] = 0;
            } else {
                wasOnLims[pos] = 0;
                steps[pos] = -step;
            }
        } else if (vals[pos] <= 0) {
            if (wasOnLims[pos] < maxTimes) {
                wasOnLims[pos]++;
                steps[pos] = 0;
            } else {
                wasOnLims[pos] = 0;
                steps[pos] = step;
            }


        }
    }

    function generateColourMatrix(width, height, step) {

        const rows = height;
        const columns = width;
        const maxTimes = maxColourValue / step;
        let colourMatrix = [];

        for (let i = 0; i < rows; i++) {
            let row = [];
            let currentSteps = [step, step, -step];
            let currentColorVals = [maxColourValue, 0, 0];
            let wasOnLimTimes = [0, maxTimes, maxTimes];
            for (let j = 0; j < columns; j++) {

                row.push(new Colour(currentColorVals[0], currentColorVals[1], currentColorVals[2]));
                // row.push(Colour.randomColour());
                applyStep(currentColorVals, currentSteps, wasOnLimTimes, 0, step, maxTimes);
                applyStep(currentColorVals, currentSteps, wasOnLimTimes, 1, step, maxTimes);
                applyStep(currentColorVals, currentSteps, wasOnLimTimes, 2, step, maxTimes);
            }
            colourMatrix.push(row);
        }
        return colourMatrix;
    }

    function drawColourMatrix(matrix, canvasCtx, imageData, actualData, canvasWidth) {
        let beforeManipulation = new Date();
        //putMatrixToCanvasData(matrix, actualData, canvasWidth)
        veryAlternativePutMatrixToCanvasData(matrix, actualData, canvasWidth)
        let beforePut = new Date();
        timeSpentOnCanvasDataManipulation += (beforePut - beforeManipulation);
        canvasCtx.putImageData(imageData, 0, 0);
        let afterPut = new Date();
        timeSpentOnActualCanvasDraw += (afterPut - beforePut);

    }

    //LACK OF OPTIMISATIONS
    function putMatrixToCanvasData(matrix, actualData, canvasWidth) {
        for (let i = 0; i < matrix.length; i++) {
            let row = matrix[i];
            for (let j = 0; j < row.length; j++) {
                let col = row[j];
                let offset = (i * canvasWidth) * 4 + j * 4;
                actualData[offset] = col.red;
                actualData[offset + 1] = col.green;
                actualData[offset + 2] = col.blue;
                actualData[offset + 3] = 255;
            }
        }
    }

    //LACK OF OPTIMISATIONS
    function alternativePutMatrixToCanvasData(matrix, actualData, canvasWidth) {
        let canvasHeight = matrix.length;
        const numberOfPixels = actualData.length / 4;
        for (let i = 0; i < numberOfPixels; i++) {
            const row = Math.floor(i / canvasWidth);
            const column = i % canvasWidth;
            const pixel = matrix[row][column];
            actualData[i * 4] = pixel.red;
            actualData[i * 4 + 1] = pixel.green;
            actualData[i * 4 + 2] = pixel.blue;
            actualData[i * 4 + 3] = 255;
        }
    }

    //LACK OF OPTIMISATIONS
    function veryAlternativePutMatrixToCanvasData(matrix, actualData, canvasWidth) {
        let canvasHeight = matrix.length;
        const numberOfPixels = actualData.length / 4;
        let pixelNumber = numberOfPixels - 1;
        while (pixelNumber) {
            const row = Math.floor(pixelNumber / canvasWidth);
            const column = pixelNumber % canvasWidth;
            const pixel = matrix[row][column];
            actualData[pixelNumber * 4] = pixel.red;
            actualData[pixelNumber * 4 + 1] = pixel.green;
            actualData[pixelNumber * 4 + 2] = pixel.blue;
            actualData[pixelNumber * 4 + 3] = 255;
            pixelNumber -= 1;
        }
        const pixel = matrix[0][0];
        actualData[0] = pixel.red;
        actualData[1] = pixel.green;
        actualData[2] = pixel.blue;
        actualData[3] = 255;
    }



</script>

</body>
</html>
